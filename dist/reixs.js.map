{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js","node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","node_modules/@babel/runtime/helpers/assertThisInitialized.js","node_modules/@babel/runtime/helpers/asyncToGenerator.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/construct.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/interopRequireWildcard.js","node_modules/@babel/runtime/helpers/iterableToArray.js","node_modules/@babel/runtime/helpers/nonIterableSpread.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/setPrototypeOf.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/typeof.js","node_modules/@babel/runtime/regenerator/index.js","node_modules/regenerator-runtime/runtime.js","src/core/constructor/index.js","src/core/constructor/reixs-all.js","src/core/constructor/reixs.js","src/core/constructor/scheduler.js","src/core/create-request/index.js","src/core/create-request/mark-map.js","src/core/create-request/request-timer.js","src/core/create-request/wait.js","src/core/request/handle-fetch.js","src/core/request/index.js","src/reixs.js","src/shared/constants.js","src/shared/utils.js"],"names":[],"mappings":"AAAA;;;ACAA,MAAM,CAAC,OAAP,GAAiB,OAAO,CAAC,aAAD,CAAP,WAAjB;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","file":"reixs.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports = require('./src/reixs').default","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","function _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nmodule.exports = _interopRequireWildcard;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import reixs from './reixs'\nimport reixsAll from './reixs-all'\n\nexport const Reixs = reixs\nexport const ReixsAll = reixsAll","\nimport createRequest from '../create-request'\n\nimport Scheduler from './scheduler'\n\n/**\n *  Separate request object\n */\nclass AllHandler  extends Scheduler {\n    _schedulers = []\n\n    constructor(...schedulers) {\n        super()\n        this._schedulers = schedulers\n        this._initRequest()\n    }\n\n    /**\n     * Create request function\n     */\n    _initRequest() {\n        const {_config, _sendRequest, _execute, _hook} = this\n        this.request = createRequest(\n            _config, \n            _sendRequest.bind(this), \n            _execute.bind(this), \n            _hook\n        )\n    }\n\n    /**\n     * Concurrent all scheduler\n     * \n     */\n    async _sendRequest() {\n        const {_schedulers} = this\n        const data = await Promise.all(_schedulers.map(scheduler=>{\n            return new Promise( resolve => {\n                scheduler.request.call({\n                    ...scheduler, \n                    injection(data) {\n                        resolve(data)\n                    }\n                })\n            })\n        }))\n        return data\n    }\n}\n\nexport default AllHandler","import {dataFiltering} from '../../shared/utils'\nimport {METHOD_TYPES} from '../../shared/constants'\n\nimport createRequest from '../create-request'\nimport * as request from '../request'\n\nimport Scheduler from './scheduler'\n\n/**\n *  Separate request object\n */\nclass Reixs  extends Scheduler {\n    constructor(url, method = 'get', params = null) {\n        super()\n\n        // Initialize the http\n        this._http = {\n            ...this._http,\n            url,\n            params\n        }\n        this.setMethod(method)\n\n        // Create request function\n        this._initRequest()\n    }\n\n    // Multiple requests Shared\n    static global = {\n        globalHeader: {},\n        globalParams: {},\n        reqPipes: [],\n        resPipes: [],\n        beforeReq: null,\n        afterReq: null,\n        beforeRes: null,\n        afterRes: null\n    }\n\n    // Network request information\n    _http = {\n        url: '',\n        method: null,\n        header: {},\n        params: null,\n        cookie: true\n    }\n\n    // Data filtering\n    _pipes = {\n        reqPipes: [],\n        resPipes: []\n    }\n\n    // Different stage interceptors\n    _interceptors = {\n        beforeReq: null, \n        afterReq: null, \n        beforeRes: null, \n        afterRes: null\n    }\n\n    /**\n     * Complete request header\n     * \n     * @return {Object} \n     */\n    get requesetHeader() {\n        const {header} = this._http\n        const {globalHeader} = this.constructor.global\n        return {\n            ...globalHeader, \n            ...header\n        }\n    }\n    \n    /**\n     * Complete request parameters\n     * \n     * @param {Object} params \n     */\n    _getParams(params) {\n        const {globalParams} = this.constructor.global\n        return {\n            ...globalParams, \n            ...params\n        }\n    }\n\n    /**\n     * Create request function\n     */\n    _initRequest() {\n        const {_config, _sendRequest, _execute, _hook} = this\n        this.request = createRequest(\n            _config, \n            _sendRequest.bind(this), \n            _execute.bind(this), \n            _hook\n        )\n    }\n\n    /**\n     * Set the request url\n     * \n     * @param {string} url \n     */\n    setUrl(url) {\n        if (typeof url === 'string') {\n            this._http.url = url\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set the request header\n     * \n     * @param {Object} header \n     */\n    setHeader(header) {\n        if (header.constructor === Object) {\n            this._http.header = header\n        } else {\n            throw new Error('Header invalid setting')\n        }\n        return this\n    }\n\n    /**\n     * Set request parameters\n     * \n     * @param {*} params \n     */\n    setParams(params) {\n        this._http.params = params\n        return this\n    }\n    \n    /**\n     * Set whether to carry cookies\n     * \n     * @param {boolean} ifCookie \n     */\n    setCookie(ifCookie) {\n        if (typeof ifCookie === 'boolean') {\n            this._http.cookie = ifCookie\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Set the request method\n     * \n     * @param {string} method \n     */\n    setMethod(method = null) {\n        method = method.toLowerCase()\n        if (METHOD_TYPES.includes(method)) {\n            this._http.method = method\n        } else {\n            throw new Error('Invalid method')\n        }\n        return this\n    }\n    \n    /**\n     * Set the request filter pipeline\n     * \n     * @param  {...any} pipes \n     */\n    reqPipes(...pipes) {\n        if (pipes.find(pipe =>typeof pipe !== 'function')) {\n            throw new Error('Pipe must be a function')\n        } else {\n            this._pipes.reqPipes = [...pipes]\n        }\n        return this\n    }\n\n    /**\n     * Set the response filter pipeline\n     * \n     * @param  {...any} pipes \n     */\n    resPipes(...pipes) {\n        if (pipes.find(pipe =>typeof pipe !== 'function')) {\n            throw new Error('Pipe must be a function')\n        } else {\n            this._pipes.resPipes = [...pipes]\n        }\n        return this\n    }\n\n    /**\n     * Set request interceptor\n     * @param {Function} interceptor \n     */\n    reqInterceptor(interceptor) {\n        if (typeof interceptor === 'function') {\n            if (this._pipes.reqPipes.length) {\n                this._interceptors.afterReq = interceptor\n            } else {\n                this._interceptors.beforeReq = interceptor\n            }\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Set response interceptor\n     * @param {Function} interceptor \n     */\n    resInterceptor(interceptor) {\n        if (typeof interceptor === 'function') {\n            if (this._pipes.resPipes.length) {\n                this._interceptors.afterRes = interceptor\n            } else {\n                this._interceptors.beforeRes = interceptor\n            }\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n\n    /**\n     * Send the request to the server\n     * \n     * @param {*} params \n     * @param {string} type \n     */\n    async _sendRequest(params = this._http.params, type) {\n        const {url, method, cookie} = this._http\n        const {errorHook} = this._hook\n        const {reqPipes, resPipes} = this._pipes\n        const {beforeReq, afterReq, beforeRes, afterRes} = this._interceptors\n        const {\n            reqPipes: globalReqPipes, \n            resPipes: globalResPipes,\n            beforeReq: globalBeforeReq,\n            afterReq: globalAfterReq,\n            beforeRes: globalBeforeRes,\n            afterRes: globalAfterRes\n        } = this.constructor.global\n        \n        const requestType = type ? type : method\n        const requestParams = requestType === 'push' \n            ? params : this._getParams(params)\n\n        if ((globalBeforeReq && globalBeforeReq(requestParams) === false) \n        || (beforeReq && beforeReq(requestParams) === false)) {\n            return \n        }\n\n        let finalParams\n        try {\n            finalParams = dataFiltering([...globalReqPipes, ...reqPipes], requestParams)\n        } catch (error) {\n            errorHook(error)\n        }\n        \n        if ((globalAfterReq && globalAfterReq(finalParams) === false) \n        || (afterReq && afterReq(finalParams) === false)) {\n            return \n        }\n\n        const data = await request[requestType](\n            url, \n            finalParams,\n            this.requesetHeader,\n            cookie\n        )\n        \n        \n        if ((globalBeforeRes && globalBeforeRes(data) === false) \n        || (beforeRes && beforeRes(data) === false)) {\n            return \n        }\n\n        let finalData\n        try {\n            finalData = dataFiltering([...globalResPipes, ...resPipes], data)\n        } catch (error) {\n            errorHook(error)\n        }\n\n        if ((globalAfterRes && globalAfterRes(finalData) === false) \n        || (afterRes && afterRes(finalData) === false)) {\n            return \n        }\n\n        return finalData\n    }\n}\n\n// Bind request category \nMETHOD_TYPES.map(requestType=>{\n    Reixs.prototype[requestType] = function(params) {\n        this.request(params, requestType)\n    }\n})\n\nexport default Reixs","\n// Scheduler is blocked from inheriting an Object\nfunction noProto() {}\nObject.setPrototypeOf(noProto.prototype, Object.create(null))\n\n/**\n * The underlying request model\n */\nexport default class extends noProto {\n    // Request trigger rule configuration\n    _config = {\n        throttle: false,\n        debounce: 0,\n        audit: false,\n        overtime: null\n    }\n\n    // Life cycle function\n    _hook = {\n        prepareHook: null,\n        tartHook: null,\n        endHook: null,\n        errorHook: null\n    }\n\n    // Task queue executed after the request is completed\n    _taskList =[]\n\n    /**\n     * Circular call task\n     * @param {*} data \n     */\n    _execute(data) {\n        const {errorHook} = this._hook\n        if (data !== undefined) {\n            try {\n                this._taskList.forEach(task =>{\n                    task(data)\n                })\n            } catch (error) {\n                errorHook && errorHook(error)\n            }\n        }\n    }\n\n    /**\n     * Set throttle\n     * \n     * @param {number|boolean} settings \n     */\n    throttle(settings) {\n        if (typeof settings === 'number' || settings === false) {\n            this._config.throttle = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Set debounce\n     * \n     * @param {number|boolean} settings \n     */\n    debounce(settings) {\n        if (typeof settings === 'number' || settings === false) {\n            this._config.debounce = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set audit\n     * \n     * @param {number|boolean} settings \n     */\n    audit(settings) {\n        if (typeof settings === 'number' || typeof settings === 'boolean') {\n            this._config.audit = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set overtime\n     * \n     * @param {number|null} time \n     */\n    overtime(time) {\n        if (typeof time === 'number' || time === null) {\n            this._config.overtime = time\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Add task\n     * \n     * @param {Function} task \n     */\n    task(task) {\n        if (typeof task === 'function') {\n            this._taskList.push(task)\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n\n    /**\n     * Request to prepare\n     * \n     * @param {Function} prepareHook \n     */\n    prepare(prepareHook) {\n        if (typeof prepareHook === 'function') {\n            this._hook.prepareHook = prepareHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n\n    /**\n     * Request to start\n     * \n     * @param {Function} startHook \n     */\n    start(startHook) {\n        if (typeof startHook === 'function') {\n            this._hook.startHook = startHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Request to end\n     * \n     * @param {Function} endHook \n     */\n    end(endHook) {\n        if (typeof endHook === 'function') {\n            this._hook.endHook = endHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Request to error\n     * \n     * @param {Function} errorHook \n     */\n    error(errorHook) {\n        if (typeof errorHook === 'function') {\n            this._hook.errorHook = errorHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n}\n\n","import MarkMap from './mark-map'\nimport {ThrottleWait, DebounceWait} from './wait'\nimport requestTimer from './request-timer'\n\n/**\n * The method to create the request\n * \n * @param {Object} config \n * @param {Function} sendRequest \n * @param {Array} execute \n * @param {Object} hook \n */ \nexport default function(config, sendRequest, execute, hook) {\n    const markMap = new MarkMap()\n    const throttleWait = new ThrottleWait()\n    const debounceWait = new DebounceWait()\n    return async function(...par) {\n        const {prepareHook, startHook, endHook} = hook\n        const {throttle, debounce, audit, overtime} = config\n\n        // External rewrite method\n        const {injection} = this\n\n        prepareHook && prepareHook()\n        let mark\n        if (audit) {\n            mark = markMap.get(audit)\n        }\n        await Promise.all([\n            throttleWait.get(throttle), \n            debounceWait.get(debounce)\n        ])\n        startHook && startHook()\n        const {timeout, data} = await requestTimer(sendRequest(...par), overtime)\n\n        if (data === undefined) {\n            endHook && endHook()\n            return \n        }\n\n        // If audit is set, the duplicate request is discarded\n        if (!audit || markMap.test(mark)) {\n            // If the timeout occurs, the task is not processed\n            if (!timeout) {\n                if (injection) {\n                    injection(data)\n                } else {\n                    execute(data)\n                }\n            }\n            endHook && endHook()\n        }\n    }\n}","/**\n * Verify that mark is deprecated\n */\nexport default class {\n    _map = []\n\n    /**\n     * Get mark\n     * @param {number|boolean} audit \n     */\n    get(audit) {\n        const {_map} = this\n        if (audit) {\n            const sym = Symbol()\n            const time = Date.now()\n            let sign\n            if (!_map.length \n                || (time - _map[_map.length - 1].time > audit \n                    && audit !== true)\n            ) {\n                sign = {\n                    sym, \n                    time\n                }\n                _map.push(sign)\n            } else {\n                sign = _map[_map.length - 1]\n                sign.sym = sym\n                sign.time = time\n            }\n\n            return {\n                sign,\n                sym: sign.sym\n            }\n        }\n        return null\n    }\n\n    /**\n     * Verify the mark\n     * @param {Object} mark \n     */\n    test(mark) {\n        if (mark && mark.sym !== mark.sign.sym) {\n            return false\n        } \n\n        if (mark) {\n            const {_map} = this\n            const index = _map.indexOf(mark.sign)\n            _map.splice(index, 1)\n        }\n        return true\n    }\n}","/**\n * Create delay promise\n * \n * @param {number} time \n */\nfunction createWait(time) {\n    return time === 0 ? Promise.resolve()\n        : new Promise(resolve=>{\n            setTimeout(()=>resolve(), time)\n        })\n}\n\n/**\n * Detect timeout\n * \n * @param {Promise} promise \n * @param {null|number} time \n */\nexport default function requestTimer(promise, time) {\n    const request = promise.then(data=>({\n        timeout: false, \n        data\n    }))\n    const timer = createWait(time).then(()=>({\n        timeout: true, \n        data: null\n    }))\n    return time === null ? request\n        : Promise.race([request, timer])\n}","/**\n * Create wait object\n */\nclass Wait {\n    _timer = null\n\n    /**\n     * Create internal promise\n     * @param {number} time \n     */\n    _createPromise(time) {\n        return time ? new Promise(resolve=>{\n            this._timer =  setTimeout(()=>{ \n                this._timer = null\n                resolve() \n            }, time)\n        }) : Promise.resolve()\n    }\n}\n\n/**\n * Create debounce wait object\n */\nexport class ThrottleWait extends Wait {\n    constructor() {\n        super()\n    }\n\n    /**\n     * get await promise\n     * @param {number} time \n     */\n    get(time) {\n        if (this._timer) {\n            return new Promise(()=>{})\n        }\n        return this._createPromise(time)\n    }\n}\n\n/**\n * Create debounce wait object\n */\nexport class DebounceWait extends Wait {\n    constructor() {\n        super()\n    }\n\n    /**\n     * get await promise\n     * @param {number} time \n     */\n    get(time) {\n        if (this._timer) {\n            clearTimeout(this._timer)\n            this._timer = null\n        }\n        return this._createPromise(time)\n    }\n}","\n/**\n * Check for success\n * \n * @param {Object} response \n */\nfunction checkStatus(response) {\n    if (response.status >= 200 && response.status < 300) {\n        const contentType = response.headers.get('content-type')\n        if (contentType && contentType.includes('application/json')) {\n            return response.json()\n        } else {\n            return response.text()\n        }\n    } else {\n        throw new Error()\n    }\n}\n\n/**\n * Handle fetch\n * \n * @param {Object} promise \n */\nexport default function handleFetch(promise) {\n    return promise\n        .then(response => checkStatus(response))\n        .catch(error => {\n            throw error\n        })\n}","import {CONTENT_TYPE} from '../../shared/constants'\nimport handleFetch from './handle-fetch'\n\n\n/**\n * Query String Parameters\n *\n * @param {string} url\n * @param {*} params\n * @param {Object} headers\n * @param {boolean} cookie\n */\nexport function get(url, params, headers, cookie) {\n    url = new URL(url)\n    Object.keys(params)\n        .forEach(key => url.searchParams.append(key, params[key]))\n    const promise = fetch(url, {\n        method: 'GET',\n        headers: {\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Dynamic Router\n *\n * @param {string} url\n * @param {*} params\n * @param {Object} headers\n * @param {boolean} cookie\n */\nexport function push(url, params, headers, cookie) {\n    url = new URL(url)\n    url.pathname += `/${params}`\n    const promise = fetch(url, {\n        method: 'GET',\n        headers: {\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Request Payload\n *\n * @param {string} url\n * @param {*} data\n * @param {Object} headers\n * @param {boolean} cookie\n */\nexport function post(url, data, headers, cookie) {\n    url = new URL(url)\n    const promise = fetch(url, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: {\n            'Content-type': CONTENT_TYPE['JSON'],\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Form Data\n *\n * @param {string} url\n * @param {*} formData\n * @param {Object} headers\n * @param {boolean} cookie\n */\nexport function form(url, formData, headers, cookie) {\n    url = new URL(url)\n    const promise = fetch(url, {\n        method: 'POST',\n        body: formData,\n        headers: {\n            'Content-type': CONTENT_TYPE['FORM'],\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n","import {Reixs, ReixsAll} from './core/constructor'\n\n/**\n * Set pipe \n * \n * @param {string} name \n * @param  {...any} funList \n */\nfunction setPipes(name, ...funList) {\n    funList.forEach(fn=>{\n        if (typeof fn !== 'function') {\n            throw new Error('Invalid type')\n        }\n    })\n    Reixs.global[name] = [...funList]\n}\n\n/**\n * Set Interceptor\n * \n * @param {string} name \n * @param {Function} fun \n */\nfunction setInterceptor(name, fun) {\n    if (typeof fn === 'function') {\n        Reixs.global[name] = fun\n    } else {\n        throw new Error('Invalid type')\n    }\n}\n\n/**\n * \n * @param {string} url \n * @param {string} method \n * @param {*} params \n */\nfunction reixs(url, method, params) {\n    return  new Reixs(url, method, params)\n}\n\n// reixs.all\nreixs.all = (...scheduler) => new ReixsAll(...scheduler)\n\n\n// Replaced by browserify-versionify transform\nreixs.version = '__VERSION__'\n\n// Set request and response pipe\nreixs.reqPipes = setPipes.bind(null, 'reqPipes')\nreixs.resPipes = setPipes.bind(null, 'resPipes')\n\n// Set request and response interceptor\nreixs.beforeReq = setInterceptor.bind(null, 'beforeReq')\nreixs.afterReq = setInterceptor.bind(null, 'afterReq')\nreixs.beforeRes = setInterceptor.bind(null, 'beforeRes')\nreixs.afterRes = setInterceptor.bind(null, 'afterRes')\n\n// Set global header\nReflect.defineProperty(reixs, 'globalHeader', {\n    set(value) {\n        Reixs.global.globalHeader = value\n    }\n})\n\n// Set global params\nReflect.defineProperty(reixs, 'globalParams', {\n    set(value) {\n        Reixs.global.globalParams = value\n    }\n})\n\nexport default reixs\n\n\n","export const METHOD_TYPES = [\n    'get',\n    'post',\n    'form',\n    'push'\n]\n\nexport const CONTENT_TYPE = {\n    JSON: 'application/json;charset=UTF-8',\n    FORM: 'application/x-www-form-urlencoded; charset=UTF-8'\n}","/**\n * Data processing\n *\n * @param {*} data \n */\nexport function dataFiltering(pipes, data) {\n    const newData = [data, ...pipes].reduce((prev, cur)=>cur(prev))\n    return newData\n}"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY29uc3RydWN0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwic3JjL2NvcmUvY29uc3RydWN0b3IvaW5kZXguanMiLCJzcmMvY29yZS9jb25zdHJ1Y3Rvci9yZWl4cy1hbGwuanMiLCJzcmMvY29yZS9jb25zdHJ1Y3Rvci9yZWl4cy5qcyIsInNyYy9jb3JlL2NvbnN0cnVjdG9yL3NjaGVkdWxlci5qcyIsInNyYy9jb3JlL2NyZWF0ZS1yZXF1ZXN0L2luZGV4LmpzIiwic3JjL2NvcmUvY3JlYXRlLXJlcXVlc3QvbWFyay1tYXAuanMiLCJzcmMvY29yZS9jcmVhdGUtcmVxdWVzdC9yZXF1ZXN0LXRpbWVyLmpzIiwic3JjL2NvcmUvY3JlYXRlLXJlcXVlc3Qvd2FpdC5qcyIsInNyYy9jb3JlL3JlcXVlc3QvaGFuZGxlLWZldGNoLmpzIiwic3JjL2NvcmUvcmVxdWVzdC9pbmRleC5qcyIsInNyYy9yZWl4cy5qcyIsInNyYy9zaGFyZWQvY29uc3RhbnRzLmpzIiwic3JjL3NoYXJlZC91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsT0FBTyxDQUFDLGFBQUQsQ0FBUCxXQUFqQjs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LENBQXVCLEtBQXZCLEVBQThCLElBQTlCLEVBQW9DO0FBQ3ZDLE1BQU0sT0FBTyxHQUFHLENBQUMsSUFBRCw2Q0FBVSxLQUFWLEdBQWlCLE1BQWpCLENBQXdCLFVBQUMsSUFBRCxFQUFPLEdBQVA7QUFBQSxXQUFhLEdBQUcsQ0FBQyxJQUFELENBQWhCO0FBQUEsR0FBeEIsQ0FBaEI7QUFDQSxTQUFPLE9BQVA7QUFDSCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvcmVpeHMnKS5kZWZhdWx0IiwiZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdDsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV3T2JqID0ge307XG5cbiAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTtcblxuICAgICAgICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqO1xuICAgIHJldHVybiBuZXdPYmo7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZjIgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YyKG9iaik7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mMihTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwiaW1wb3J0IHJlaXhzIGZyb20gJy4vcmVpeHMnXG5pbXBvcnQgcmVpeHNBbGwgZnJvbSAnLi9yZWl4cy1hbGwnXG5cbmV4cG9ydCBjb25zdCBSZWl4cyA9IHJlaXhzXG5leHBvcnQgY29uc3QgUmVpeHNBbGwgPSByZWl4c0FsbCIsIlxuaW1wb3J0IGNyZWF0ZVJlcXVlc3QgZnJvbSAnLi4vY3JlYXRlLXJlcXVlc3QnXG5cbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnLi9zY2hlZHVsZXInXG5cbi8qKlxuICogIFNlcGFyYXRlIHJlcXVlc3Qgb2JqZWN0XG4gKi9cbmNsYXNzIEFsbEhhbmRsZXIgIGV4dGVuZHMgU2NoZWR1bGVyIHtcbiAgICBfc2NoZWR1bGVycyA9IFtdXG5cbiAgICBjb25zdHJ1Y3RvciguLi5zY2hlZHVsZXJzKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVycyA9IHNjaGVkdWxlcnNcbiAgICAgICAgdGhpcy5faW5pdFJlcXVlc3QoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSByZXF1ZXN0IGZ1bmN0aW9uXG4gICAgICovXG4gICAgX2luaXRSZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCB7X2NvbmZpZywgX3NlbmRSZXF1ZXN0LCBfZXhlY3V0ZSwgX2hvb2t9ID0gdGhpc1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0KFxuICAgICAgICAgICAgX2NvbmZpZywgXG4gICAgICAgICAgICBfc2VuZFJlcXVlc3QuYmluZCh0aGlzKSwgXG4gICAgICAgICAgICBfZXhlY3V0ZS5iaW5kKHRoaXMpLCBcbiAgICAgICAgICAgIF9ob29rXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25jdXJyZW50IGFsbCBzY2hlZHVsZXJcbiAgICAgKiBcbiAgICAgKi9cbiAgICBhc3luYyBfc2VuZFJlcXVlc3QoKSB7XG4gICAgICAgIGNvbnN0IHtfc2NoZWR1bGVyc30gPSB0aGlzXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBQcm9taXNlLmFsbChfc2NoZWR1bGVycy5tYXAoc2NoZWR1bGVyPT57XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoIHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlci5yZXF1ZXN0LmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAuLi5zY2hlZHVsZXIsIFxuICAgICAgICAgICAgICAgICAgICBpbmplY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pKVxuICAgICAgICByZXR1cm4gZGF0YVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWxsSGFuZGxlciIsImltcG9ydCB7ZGF0YUZpbHRlcmluZ30gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzJ1xuaW1wb3J0IHtNRVRIT0RfVFlQRVN9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMnXG5cbmltcG9ydCBjcmVhdGVSZXF1ZXN0IGZyb20gJy4uL2NyZWF0ZS1yZXF1ZXN0J1xuaW1wb3J0ICogYXMgcmVxdWVzdCBmcm9tICcuLi9yZXF1ZXN0J1xuXG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJy4vc2NoZWR1bGVyJ1xuXG4vKipcbiAqICBTZXBhcmF0ZSByZXF1ZXN0IG9iamVjdFxuICovXG5jbGFzcyBSZWl4cyAgZXh0ZW5kcyBTY2hlZHVsZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbWV0aG9kID0gJ2dldCcsIHBhcmFtcyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoKVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGh0dHBcbiAgICAgICAgdGhpcy5faHR0cCA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2h0dHAsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE1ldGhvZChtZXRob2QpXG5cbiAgICAgICAgLy8gQ3JlYXRlIHJlcXVlc3QgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5faW5pdFJlcXVlc3QoKVxuICAgIH1cblxuICAgIC8vIE11bHRpcGxlIHJlcXVlc3RzIFNoYXJlZFxuICAgIHN0YXRpYyBnbG9iYWwgPSB7XG4gICAgICAgIGdsb2JhbEhlYWRlcjoge30sXG4gICAgICAgIGdsb2JhbFBhcmFtczoge30sXG4gICAgICAgIHJlcVBpcGVzOiBbXSxcbiAgICAgICAgcmVzUGlwZXM6IFtdLFxuICAgICAgICBiZWZvcmVSZXE6IG51bGwsXG4gICAgICAgIGFmdGVyUmVxOiBudWxsLFxuICAgICAgICBiZWZvcmVSZXM6IG51bGwsXG4gICAgICAgIGFmdGVyUmVzOiBudWxsXG4gICAgfVxuXG4gICAgLy8gTmV0d29yayByZXF1ZXN0IGluZm9ybWF0aW9uXG4gICAgX2h0dHAgPSB7XG4gICAgICAgIHVybDogJycsXG4gICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgaGVhZGVyOiB7fSxcbiAgICAgICAgcGFyYW1zOiBudWxsLFxuICAgICAgICBjb29raWU6IHRydWVcbiAgICB9XG5cbiAgICAvLyBEYXRhIGZpbHRlcmluZ1xuICAgIF9waXBlcyA9IHtcbiAgICAgICAgcmVxUGlwZXM6IFtdLFxuICAgICAgICByZXNQaXBlczogW11cbiAgICB9XG5cbiAgICAvLyBEaWZmZXJlbnQgc3RhZ2UgaW50ZXJjZXB0b3JzXG4gICAgX2ludGVyY2VwdG9ycyA9IHtcbiAgICAgICAgYmVmb3JlUmVxOiBudWxsLCBcbiAgICAgICAgYWZ0ZXJSZXE6IG51bGwsIFxuICAgICAgICBiZWZvcmVSZXM6IG51bGwsIFxuICAgICAgICBhZnRlclJlczogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIHJlcXVlc3QgaGVhZGVyXG4gICAgICogXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBcbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzZXRIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IHtoZWFkZXJ9ID0gdGhpcy5faHR0cFxuICAgICAgICBjb25zdCB7Z2xvYmFsSGVhZGVyfSA9IHRoaXMuY29uc3RydWN0b3IuZ2xvYmFsXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nbG9iYWxIZWFkZXIsIFxuICAgICAgICAgICAgLi4uaGVhZGVyXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQ29tcGxldGUgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBcbiAgICAgKi9cbiAgICBfZ2V0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7Z2xvYmFsUGFyYW1zfSA9IHRoaXMuY29uc3RydWN0b3IuZ2xvYmFsXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nbG9iYWxQYXJhbXMsIFxuICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcmVxdWVzdCBmdW5jdGlvblxuICAgICAqL1xuICAgIF9pbml0UmVxdWVzdCgpIHtcbiAgICAgICAgY29uc3Qge19jb25maWcsIF9zZW5kUmVxdWVzdCwgX2V4ZWN1dGUsIF9ob29rfSA9IHRoaXNcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChcbiAgICAgICAgICAgIF9jb25maWcsIFxuICAgICAgICAgICAgX3NlbmRSZXF1ZXN0LmJpbmQodGhpcyksIFxuICAgICAgICAgICAgX2V4ZWN1dGUuYmluZCh0aGlzKSwgXG4gICAgICAgICAgICBfaG9va1xuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IHVybFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgXG4gICAgICovXG4gICAgc2V0VXJsKHVybCkge1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAudXJsID0gdXJsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IGhlYWRlclxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXIgXG4gICAgICovXG4gICAgc2V0SGVhZGVyKGhlYWRlcikge1xuICAgICAgICBpZiAoaGVhZGVyLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAuaGVhZGVyID0gaGVhZGVyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYWRlciBpbnZhbGlkIHNldHRpbmcnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHJlcXVlc3QgcGFyYW1ldGVyc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gcGFyYW1zIFxuICAgICAqL1xuICAgIHNldFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5faHR0cC5wYXJhbXMgPSBwYXJhbXNcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdG8gY2FycnkgY29va2llc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWZDb29raWUgXG4gICAgICovXG4gICAgc2V0Q29va2llKGlmQ29va2llKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWZDb29raWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5faHR0cC5jb29raWUgPSBpZkNvb2tpZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IG1ldGhvZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgXG4gICAgICovXG4gICAgc2V0TWV0aG9kKG1ldGhvZCA9IG51bGwpIHtcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKClcbiAgICAgICAgaWYgKE1FVEhPRF9UWVBFUy5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzLl9odHRwLm1ldGhvZCA9IG1ldGhvZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCcpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IGZpbHRlciBwaXBlbGluZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gcGlwZXMgXG4gICAgICovXG4gICAgcmVxUGlwZXMoLi4ucGlwZXMpIHtcbiAgICAgICAgaWYgKHBpcGVzLmZpbmQocGlwZSA9PnR5cGVvZiBwaXBlICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXBlIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9waXBlcy5yZXFQaXBlcyA9IFsuLi5waXBlc11cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcmVzcG9uc2UgZmlsdGVyIHBpcGVsaW5lXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBwaXBlcyBcbiAgICAgKi9cbiAgICByZXNQaXBlcyguLi5waXBlcykge1xuICAgICAgICBpZiAocGlwZXMuZmluZChwaXBlID0+dHlwZW9mIHBpcGUgIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpcGUgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BpcGVzLnJlc1BpcGVzID0gWy4uLnBpcGVzXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHJlcXVlc3QgaW50ZXJjZXB0b3JcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBcbiAgICAgKi9cbiAgICByZXFJbnRlcmNlcHRvcihpbnRlcmNlcHRvcikge1xuICAgICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGlwZXMucmVxUGlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJjZXB0b3JzLmFmdGVyUmVxID0gaW50ZXJjZXB0b3JcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJjZXB0b3JzLmJlZm9yZVJlcSA9IGludGVyY2VwdG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFNldCByZXNwb25zZSBpbnRlcmNlcHRvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFxuICAgICAqL1xuICAgIHJlc0ludGVyY2VwdG9yKGludGVyY2VwdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9waXBlcy5yZXNQaXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcmNlcHRvcnMuYWZ0ZXJSZXMgPSBpbnRlcmNlcHRvclxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcmNlcHRvcnMuYmVmb3JlUmVzID0gaW50ZXJjZXB0b3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0geyp9IHBhcmFtcyBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBcbiAgICAgKi9cbiAgICBhc3luYyBfc2VuZFJlcXVlc3QocGFyYW1zID0gdGhpcy5faHR0cC5wYXJhbXMsIHR5cGUpIHtcbiAgICAgICAgY29uc3Qge3VybCwgbWV0aG9kLCBjb29raWV9ID0gdGhpcy5faHR0cFxuICAgICAgICBjb25zdCB7ZXJyb3JIb29rfSA9IHRoaXMuX2hvb2tcbiAgICAgICAgY29uc3Qge3JlcVBpcGVzLCByZXNQaXBlc30gPSB0aGlzLl9waXBlc1xuICAgICAgICBjb25zdCB7YmVmb3JlUmVxLCBhZnRlclJlcSwgYmVmb3JlUmVzLCBhZnRlclJlc30gPSB0aGlzLl9pbnRlcmNlcHRvcnNcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcmVxUGlwZXM6IGdsb2JhbFJlcVBpcGVzLCBcbiAgICAgICAgICAgIHJlc1BpcGVzOiBnbG9iYWxSZXNQaXBlcyxcbiAgICAgICAgICAgIGJlZm9yZVJlcTogZ2xvYmFsQmVmb3JlUmVxLFxuICAgICAgICAgICAgYWZ0ZXJSZXE6IGdsb2JhbEFmdGVyUmVxLFxuICAgICAgICAgICAgYmVmb3JlUmVzOiBnbG9iYWxCZWZvcmVSZXMsXG4gICAgICAgICAgICBhZnRlclJlczogZ2xvYmFsQWZ0ZXJSZXNcbiAgICAgICAgfSA9IHRoaXMuY29uc3RydWN0b3IuZ2xvYmFsXG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXF1ZXN0VHlwZSA9IHR5cGUgPyB0eXBlIDogbWV0aG9kXG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSByZXF1ZXN0VHlwZSA9PT0gJ3B1c2gnIFxuICAgICAgICAgICAgPyBwYXJhbXMgOiB0aGlzLl9nZXRQYXJhbXMocGFyYW1zKVxuXG4gICAgICAgIGlmICgoZ2xvYmFsQmVmb3JlUmVxICYmIGdsb2JhbEJlZm9yZVJlcShyZXF1ZXN0UGFyYW1zKSA9PT0gZmFsc2UpIFxuICAgICAgICB8fCAoYmVmb3JlUmVxICYmIGJlZm9yZVJlcShyZXF1ZXN0UGFyYW1zKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmluYWxQYXJhbXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmFsUGFyYW1zID0gZGF0YUZpbHRlcmluZyhbLi4uZ2xvYmFsUmVxUGlwZXMsIC4uLnJlcVBpcGVzXSwgcmVxdWVzdFBhcmFtcylcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9ySG9vayhlcnJvcilcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKChnbG9iYWxBZnRlclJlcSAmJiBnbG9iYWxBZnRlclJlcShmaW5hbFBhcmFtcykgPT09IGZhbHNlKSBcbiAgICAgICAgfHwgKGFmdGVyUmVxICYmIGFmdGVyUmVxKGZpbmFsUGFyYW1zKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVxdWVzdFtyZXF1ZXN0VHlwZV0oXG4gICAgICAgICAgICB1cmwsIFxuICAgICAgICAgICAgZmluYWxQYXJhbXMsXG4gICAgICAgICAgICB0aGlzLnJlcXVlc2V0SGVhZGVyLFxuICAgICAgICAgICAgY29va2llXG4gICAgICAgIClcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZiAoKGdsb2JhbEJlZm9yZVJlcyAmJiBnbG9iYWxCZWZvcmVSZXMoZGF0YSkgPT09IGZhbHNlKSBcbiAgICAgICAgfHwgKGJlZm9yZVJlcyAmJiBiZWZvcmVSZXMoZGF0YSkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZpbmFsRGF0YVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmluYWxEYXRhID0gZGF0YUZpbHRlcmluZyhbLi4uZ2xvYmFsUmVzUGlwZXMsIC4uLnJlc1BpcGVzXSwgZGF0YSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9ySG9vayhlcnJvcilcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoZ2xvYmFsQWZ0ZXJSZXMgJiYgZ2xvYmFsQWZ0ZXJSZXMoZmluYWxEYXRhKSA9PT0gZmFsc2UpIFxuICAgICAgICB8fCAoYWZ0ZXJSZXMgJiYgYWZ0ZXJSZXMoZmluYWxEYXRhKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmluYWxEYXRhXG4gICAgfVxufVxuXG4vLyBCaW5kIHJlcXVlc3QgY2F0ZWdvcnkgXG5NRVRIT0RfVFlQRVMubWFwKHJlcXVlc3RUeXBlPT57XG4gICAgUmVpeHMucHJvdG90eXBlW3JlcXVlc3RUeXBlXSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB0aGlzLnJlcXVlc3QocGFyYW1zLCByZXF1ZXN0VHlwZSlcbiAgICB9XG59KVxuXG5leHBvcnQgZGVmYXVsdCBSZWl4cyIsIlxuLy8gU2NoZWR1bGVyIGlzIGJsb2NrZWQgZnJvbSBpbmhlcml0aW5nIGFuIE9iamVjdFxuZnVuY3Rpb24gbm9Qcm90bygpIHt9XG5PYmplY3Quc2V0UHJvdG90eXBlT2Yobm9Qcm90by5wcm90b3R5cGUsIE9iamVjdC5jcmVhdGUobnVsbCkpXG5cbi8qKlxuICogVGhlIHVuZGVybHlpbmcgcmVxdWVzdCBtb2RlbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIG5vUHJvdG8ge1xuICAgIC8vIFJlcXVlc3QgdHJpZ2dlciBydWxlIGNvbmZpZ3VyYXRpb25cbiAgICBfY29uZmlnID0ge1xuICAgICAgICB0aHJvdHRsZTogZmFsc2UsXG4gICAgICAgIGRlYm91bmNlOiAwLFxuICAgICAgICBhdWRpdDogZmFsc2UsXG4gICAgICAgIG92ZXJ0aW1lOiBudWxsXG4gICAgfVxuXG4gICAgLy8gTGlmZSBjeWNsZSBmdW5jdGlvblxuICAgIF9ob29rID0ge1xuICAgICAgICBwcmVwYXJlSG9vazogbnVsbCxcbiAgICAgICAgdGFydEhvb2s6IG51bGwsXG4gICAgICAgIGVuZEhvb2s6IG51bGwsXG4gICAgICAgIGVycm9ySG9vazogbnVsbFxuICAgIH1cblxuICAgIC8vIFRhc2sgcXVldWUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIHJlcXVlc3QgaXMgY29tcGxldGVkXG4gICAgX3Rhc2tMaXN0ID1bXVxuXG4gICAgLyoqXG4gICAgICogQ2lyY3VsYXIgY2FsbCB0YXNrXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFxuICAgICAqL1xuICAgIF9leGVjdXRlKGRhdGEpIHtcbiAgICAgICAgY29uc3Qge2Vycm9ySG9va30gPSB0aGlzLl9ob29rXG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFza0xpc3QuZm9yRWFjaCh0YXNrID0+e1xuICAgICAgICAgICAgICAgICAgICB0YXNrKGRhdGEpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JIb29rICYmIGVycm9ySG9vayhlcnJvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aHJvdHRsZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IHNldHRpbmdzIFxuICAgICAqL1xuICAgIHRocm90dGxlKHNldHRpbmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdudW1iZXInIHx8IHNldHRpbmdzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLnRocm90dGxlID0gc2V0dGluZ3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBkZWJvdW5jZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IHNldHRpbmdzIFxuICAgICAqL1xuICAgIGRlYm91bmNlKHNldHRpbmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdudW1iZXInIHx8IHNldHRpbmdzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLmRlYm91bmNlID0gc2V0dGluZ3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBTZXQgYXVkaXRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcnxib29sZWFufSBzZXR0aW5ncyBcbiAgICAgKi9cbiAgICBhdWRpdChzZXR0aW5ncykge1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc2V0dGluZ3MgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLmF1ZGl0ID0gc2V0dGluZ3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBTZXQgb3ZlcnRpbWVcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcnxudWxsfSB0aW1lIFxuICAgICAqL1xuICAgIG92ZXJ0aW1lKHRpbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lID09PSAnbnVtYmVyJyB8fCB0aW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcub3ZlcnRpbWUgPSB0aW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGFza1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2sgXG4gICAgICovXG4gICAgdGFzayh0YXNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fdGFza0xpc3QucHVzaCh0YXNrKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdG8gcHJlcGFyZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXBhcmVIb29rIFxuICAgICAqL1xuICAgIHByZXBhcmUocHJlcGFyZUhvb2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVwYXJlSG9vayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5faG9vay5wcmVwYXJlSG9vayA9IHByZXBhcmVIb29rXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0byBzdGFydFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0YXJ0SG9vayBcbiAgICAgKi9cbiAgICBzdGFydChzdGFydEhvb2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFydEhvb2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvb2suc3RhcnRIb29rID0gc3RhcnRIb29rXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdG8gZW5kXG4gICAgICogXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZW5kSG9vayBcbiAgICAgKi9cbiAgICBlbmQoZW5kSG9vaykge1xuICAgICAgICBpZiAodHlwZW9mIGVuZEhvb2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvb2suZW5kSG9vayA9IGVuZEhvb2tcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0byBlcnJvclxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9ySG9vayBcbiAgICAgKi9cbiAgICBlcnJvcihlcnJvckhvb2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvckhvb2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvb2suZXJyb3JIb29rID0gZXJyb3JIb29rXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgTWFya01hcCBmcm9tICcuL21hcmstbWFwJ1xuaW1wb3J0IHtUaHJvdHRsZVdhaXQsIERlYm91bmNlV2FpdH0gZnJvbSAnLi93YWl0J1xuaW1wb3J0IHJlcXVlc3RUaW1lciBmcm9tICcuL3JlcXVlc3QtdGltZXInXG5cbi8qKlxuICogVGhlIG1ldGhvZCB0byBjcmVhdGUgdGhlIHJlcXVlc3RcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNlbmRSZXF1ZXN0IFxuICogQHBhcmFtIHtBcnJheX0gZXhlY3V0ZSBcbiAqIEBwYXJhbSB7T2JqZWN0fSBob29rIFxuICovIFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29uZmlnLCBzZW5kUmVxdWVzdCwgZXhlY3V0ZSwgaG9vaykge1xuICAgIGNvbnN0IG1hcmtNYXAgPSBuZXcgTWFya01hcCgpXG4gICAgY29uc3QgdGhyb3R0bGVXYWl0ID0gbmV3IFRocm90dGxlV2FpdCgpXG4gICAgY29uc3QgZGVib3VuY2VXYWl0ID0gbmV3IERlYm91bmNlV2FpdCgpXG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKC4uLnBhcikge1xuICAgICAgICBjb25zdCB7cHJlcGFyZUhvb2ssIHN0YXJ0SG9vaywgZW5kSG9va30gPSBob29rXG4gICAgICAgIGNvbnN0IHt0aHJvdHRsZSwgZGVib3VuY2UsIGF1ZGl0LCBvdmVydGltZX0gPSBjb25maWdcblxuICAgICAgICAvLyBFeHRlcm5hbCByZXdyaXRlIG1ldGhvZFxuICAgICAgICBjb25zdCB7aW5qZWN0aW9ufSA9IHRoaXNcblxuICAgICAgICBwcmVwYXJlSG9vayAmJiBwcmVwYXJlSG9vaygpXG4gICAgICAgIGxldCBtYXJrXG4gICAgICAgIGlmIChhdWRpdCkge1xuICAgICAgICAgICAgbWFyayA9IG1hcmtNYXAuZ2V0KGF1ZGl0KVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRocm90dGxlV2FpdC5nZXQodGhyb3R0bGUpLCBcbiAgICAgICAgICAgIGRlYm91bmNlV2FpdC5nZXQoZGVib3VuY2UpXG4gICAgICAgIF0pXG4gICAgICAgIHN0YXJ0SG9vayAmJiBzdGFydEhvb2soKVxuICAgICAgICBjb25zdCB7dGltZW91dCwgZGF0YX0gPSBhd2FpdCByZXF1ZXN0VGltZXIoc2VuZFJlcXVlc3QoLi4ucGFyKSwgb3ZlcnRpbWUpXG5cbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5kSG9vayAmJiBlbmRIb29rKClcbiAgICAgICAgICAgIHJldHVybiBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGF1ZGl0IGlzIHNldCwgdGhlIGR1cGxpY2F0ZSByZXF1ZXN0IGlzIGRpc2NhcmRlZFxuICAgICAgICBpZiAoIWF1ZGl0IHx8IG1hcmtNYXAudGVzdChtYXJrKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRpbWVvdXQgb2NjdXJzLCB0aGUgdGFzayBpcyBub3QgcHJvY2Vzc2VkXG4gICAgICAgICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5qZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdGlvbihkYXRhKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGUoZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRIb29rICYmIGVuZEhvb2soKVxuICAgICAgICB9XG4gICAgfVxufSIsIi8qKlxuICogVmVyaWZ5IHRoYXQgbWFyayBpcyBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgICBfbWFwID0gW11cblxuICAgIC8qKlxuICAgICAqIEdldCBtYXJrXG4gICAgICogQHBhcmFtIHtudW1iZXJ8Ym9vbGVhbn0gYXVkaXQgXG4gICAgICovXG4gICAgZ2V0KGF1ZGl0KSB7XG4gICAgICAgIGNvbnN0IHtfbWFwfSA9IHRoaXNcbiAgICAgICAgaWYgKGF1ZGl0KSB7XG4gICAgICAgICAgICBjb25zdCBzeW0gPSBTeW1ib2woKVxuICAgICAgICAgICAgY29uc3QgdGltZSA9IERhdGUubm93KClcbiAgICAgICAgICAgIGxldCBzaWduXG4gICAgICAgICAgICBpZiAoIV9tYXAubGVuZ3RoIFxuICAgICAgICAgICAgICAgIHx8ICh0aW1lIC0gX21hcFtfbWFwLmxlbmd0aCAtIDFdLnRpbWUgPiBhdWRpdCBcbiAgICAgICAgICAgICAgICAgICAgJiYgYXVkaXQgIT09IHRydWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzaWduID0ge1xuICAgICAgICAgICAgICAgICAgICBzeW0sIFxuICAgICAgICAgICAgICAgICAgICB0aW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9tYXAucHVzaChzaWduKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduID0gX21hcFtfbWFwLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgc2lnbi5zeW0gPSBzeW1cbiAgICAgICAgICAgICAgICBzaWduLnRpbWUgPSB0aW1lXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgICAgICBzeW06IHNpZ24uc3ltXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgdGhlIG1hcmtcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFyayBcbiAgICAgKi9cbiAgICB0ZXN0KG1hcmspIHtcbiAgICAgICAgaWYgKG1hcmsgJiYgbWFyay5zeW0gIT09IG1hcmsuc2lnbi5zeW0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBjb25zdCB7X21hcH0gPSB0aGlzXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IF9tYXAuaW5kZXhPZihtYXJrLnNpZ24pXG4gICAgICAgICAgICBfbWFwLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbn0iLCIvKipcbiAqIENyZWF0ZSBkZWxheSBwcm9taXNlXG4gKiBcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFxuICovXG5mdW5jdGlvbiBjcmVhdGVXYWl0KHRpbWUpIHtcbiAgICByZXR1cm4gdGltZSA9PT0gMCA/IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIDogbmV3IFByb21pc2UocmVzb2x2ZT0+e1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+cmVzb2x2ZSgpLCB0aW1lKVxuICAgICAgICB9KVxufVxuXG4vKipcbiAqIERldGVjdCB0aW1lb3V0XG4gKiBcbiAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBcbiAqIEBwYXJhbSB7bnVsbHxudW1iZXJ9IHRpbWUgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcXVlc3RUaW1lcihwcm9taXNlLCB0aW1lKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHByb21pc2UudGhlbihkYXRhPT4oe1xuICAgICAgICB0aW1lb3V0OiBmYWxzZSwgXG4gICAgICAgIGRhdGFcbiAgICB9KSlcbiAgICBjb25zdCB0aW1lciA9IGNyZWF0ZVdhaXQodGltZSkudGhlbigoKT0+KHtcbiAgICAgICAgdGltZW91dDogdHJ1ZSwgXG4gICAgICAgIGRhdGE6IG51bGxcbiAgICB9KSlcbiAgICByZXR1cm4gdGltZSA9PT0gbnVsbCA/IHJlcXVlc3RcbiAgICAgICAgOiBQcm9taXNlLnJhY2UoW3JlcXVlc3QsIHRpbWVyXSlcbn0iLCIvKipcbiAqIENyZWF0ZSB3YWl0IG9iamVjdFxuICovXG5jbGFzcyBXYWl0IHtcbiAgICBfdGltZXIgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgaW50ZXJuYWwgcHJvbWlzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFxuICAgICAqL1xuICAgIF9jcmVhdGVQcm9taXNlKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUgPyBuZXcgUHJvbWlzZShyZXNvbHZlPT57XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9ICBzZXRUaW1lb3V0KCgpPT57IFxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbFxuICAgICAgICAgICAgICAgIHJlc29sdmUoKSBcbiAgICAgICAgICAgIH0sIHRpbWUpXG4gICAgICAgIH0pIDogUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGRlYm91bmNlIHdhaXQgb2JqZWN0XG4gKi9cbmV4cG9ydCBjbGFzcyBUaHJvdHRsZVdhaXQgZXh0ZW5kcyBXYWl0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhd2FpdCBwcm9taXNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgXG4gICAgICovXG4gICAgZ2V0KHRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQcm9taXNlKHRpbWUpXG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBkZWJvdW5jZSB3YWl0IG9iamVjdFxuICovXG5leHBvcnQgY2xhc3MgRGVib3VuY2VXYWl0IGV4dGVuZHMgV2FpdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYXdhaXQgcHJvbWlzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFxuICAgICAqL1xuICAgIGdldCh0aW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKVxuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVByb21pc2UodGltZSlcbiAgICB9XG59IiwiXG4vKipcbiAqIENoZWNrIGZvciBzdWNjZXNzXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBcbiAqL1xuZnVuY3Rpb24gY2hlY2tTdGF0dXMocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJylcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KClcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpXG4gICAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBmZXRjaFxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvbWlzZSBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGFuZGxlRmV0Y2gocHJvbWlzZSkge1xuICAgIHJldHVybiBwcm9taXNlXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IGNoZWNrU3RhdHVzKHJlc3BvbnNlKSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH0pXG59IiwiaW1wb3J0IHtDT05URU5UX1RZUEV9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMnXG5pbXBvcnQgaGFuZGxlRmV0Y2ggZnJvbSAnLi9oYW5kbGUtZmV0Y2gnXG5cblxuLyoqXG4gKiBRdWVyeSBTdHJpbmcgUGFyYW1ldGVyc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7Kn0gcGFyYW1zXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xuICogQHBhcmFtIHtib29sZWFufSBjb29raWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldCh1cmwsIHBhcmFtcywgaGVhZGVycywgY29va2llKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgT2JqZWN0LmtleXMocGFyYW1zKVxuICAgICAgICAuZm9yRWFjaChrZXkgPT4gdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBwYXJhbXNba2V5XSkpXG4gICAgY29uc3QgcHJvbWlzZSA9IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiBjb29raWUgPyAnaW5jbHVkZScgOiAnb21pdCdcbiAgICB9KVxuICAgIHJldHVybiBoYW5kbGVGZXRjaChwcm9taXNlKVxufVxuXG4vKipcbiAqIER5bmFtaWMgUm91dGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHsqfSBwYXJhbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvb2tpZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaCh1cmwsIHBhcmFtcywgaGVhZGVycywgY29va2llKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgdXJsLnBhdGhuYW1lICs9IGAvJHtwYXJhbXN9YFxuICAgIGNvbnN0IHByb21pc2UgPSBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogY29va2llID8gJ2luY2x1ZGUnIDogJ29taXQnXG4gICAgfSlcbiAgICByZXR1cm4gaGFuZGxlRmV0Y2gocHJvbWlzZSlcbn1cblxuLyoqXG4gKiBSZXF1ZXN0IFBheWxvYWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvb2tpZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9zdCh1cmwsIGRhdGEsIGhlYWRlcnMsIGNvb2tpZSkge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKVxuICAgIGNvbnN0IHByb21pc2UgPSBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC10eXBlJzogQ09OVEVOVF9UWVBFWydKU09OJ10sXG4gICAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiBjb29raWUgPyAnaW5jbHVkZScgOiAnb21pdCdcbiAgICB9KVxuICAgIHJldHVybiBoYW5kbGVGZXRjaChwcm9taXNlKVxufVxuXG4vKipcbiAqIEZvcm0gRGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7Kn0gZm9ybURhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvb2tpZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybSh1cmwsIGZvcm1EYXRhLCBoZWFkZXJzLCBjb29raWUpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybClcbiAgICBjb25zdCBwcm9taXNlID0gZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtdHlwZSc6IENPTlRFTlRfVFlQRVsnRk9STSddLFxuICAgICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogY29va2llID8gJ2luY2x1ZGUnIDogJ29taXQnXG4gICAgfSlcbiAgICByZXR1cm4gaGFuZGxlRmV0Y2gocHJvbWlzZSlcbn1cbiIsImltcG9ydCB7UmVpeHMsIFJlaXhzQWxsfSBmcm9tICcuL2NvcmUvY29uc3RydWN0b3InXG5cbi8qKlxuICogU2V0IHBpcGUgXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICogQHBhcmFtICB7Li4uYW55fSBmdW5MaXN0IFxuICovXG5mdW5jdGlvbiBzZXRQaXBlcyhuYW1lLCAuLi5mdW5MaXN0KSB7XG4gICAgZnVuTGlzdC5mb3JFYWNoKGZuPT57XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgIH0pXG4gICAgUmVpeHMuZ2xvYmFsW25hbWVdID0gWy4uLmZ1bkxpc3RdXG59XG5cbi8qKlxuICogU2V0IEludGVyY2VwdG9yXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuIFxuICovXG5mdW5jdGlvbiBzZXRJbnRlcmNlcHRvcihuYW1lLCBmdW4pIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIFJlaXhzLmdsb2JhbFtuYW1lXSA9IGZ1blxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICB9XG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBcbiAqIEBwYXJhbSB7Kn0gcGFyYW1zIFxuICovXG5mdW5jdGlvbiByZWl4cyh1cmwsIG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuICBuZXcgUmVpeHModXJsLCBtZXRob2QsIHBhcmFtcylcbn1cblxuLy8gcmVpeHMuYWxsXG5yZWl4cy5hbGwgPSAoLi4uc2NoZWR1bGVyKSA9PiBuZXcgUmVpeHNBbGwoLi4uc2NoZWR1bGVyKVxuXG5cbi8vIFJlcGxhY2VkIGJ5IGJyb3dzZXJpZnktdmVyc2lvbmlmeSB0cmFuc2Zvcm1cbnJlaXhzLnZlcnNpb24gPSAnX19WRVJTSU9OX18nXG5cbi8vIFNldCByZXF1ZXN0IGFuZCByZXNwb25zZSBwaXBlXG5yZWl4cy5yZXFQaXBlcyA9IHNldFBpcGVzLmJpbmQobnVsbCwgJ3JlcVBpcGVzJylcbnJlaXhzLnJlc1BpcGVzID0gc2V0UGlwZXMuYmluZChudWxsLCAncmVzUGlwZXMnKVxuXG4vLyBTZXQgcmVxdWVzdCBhbmQgcmVzcG9uc2UgaW50ZXJjZXB0b3JcbnJlaXhzLmJlZm9yZVJlcSA9IHNldEludGVyY2VwdG9yLmJpbmQobnVsbCwgJ2JlZm9yZVJlcScpXG5yZWl4cy5hZnRlclJlcSA9IHNldEludGVyY2VwdG9yLmJpbmQobnVsbCwgJ2FmdGVyUmVxJylcbnJlaXhzLmJlZm9yZVJlcyA9IHNldEludGVyY2VwdG9yLmJpbmQobnVsbCwgJ2JlZm9yZVJlcycpXG5yZWl4cy5hZnRlclJlcyA9IHNldEludGVyY2VwdG9yLmJpbmQobnVsbCwgJ2FmdGVyUmVzJylcblxuLy8gU2V0IGdsb2JhbCBoZWFkZXJcblJlZmxlY3QuZGVmaW5lUHJvcGVydHkocmVpeHMsICdnbG9iYWxIZWFkZXInLCB7XG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIFJlaXhzLmdsb2JhbC5nbG9iYWxIZWFkZXIgPSB2YWx1ZVxuICAgIH1cbn0pXG5cbi8vIFNldCBnbG9iYWwgcGFyYW1zXG5SZWZsZWN0LmRlZmluZVByb3BlcnR5KHJlaXhzLCAnZ2xvYmFsUGFyYW1zJywge1xuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBSZWl4cy5nbG9iYWwuZ2xvYmFsUGFyYW1zID0gdmFsdWVcbiAgICB9XG59KVxuXG5leHBvcnQgZGVmYXVsdCByZWl4c1xuXG5cbiIsImV4cG9ydCBjb25zdCBNRVRIT0RfVFlQRVMgPSBbXG4gICAgJ2dldCcsXG4gICAgJ3Bvc3QnLFxuICAgICdmb3JtJyxcbiAgICAncHVzaCdcbl1cblxuZXhwb3J0IGNvbnN0IENPTlRFTlRfVFlQRSA9IHtcbiAgICBKU09OOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JyxcbiAgICBGT1JNOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04J1xufSIsIi8qKlxuICogRGF0YSBwcm9jZXNzaW5nXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YUZpbHRlcmluZyhwaXBlcywgZGF0YSkge1xuICAgIGNvbnN0IG5ld0RhdGEgPSBbZGF0YSwgLi4ucGlwZXNdLnJlZHVjZSgocHJldiwgY3VyKT0+Y3VyKHByZXYpKVxuICAgIHJldHVybiBuZXdEYXRhXG59Il19"}