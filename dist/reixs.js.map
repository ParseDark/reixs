{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js","node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","node_modules/@babel/runtime/helpers/assertThisInitialized.js","node_modules/@babel/runtime/helpers/asyncToGenerator.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/interopRequireWildcard.js","node_modules/@babel/runtime/helpers/iterableToArray.js","node_modules/@babel/runtime/helpers/nonIterableSpread.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/setPrototypeOf.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/typeof.js","node_modules/@babel/runtime/regenerator/index.js","node_modules/regenerator-runtime/runtime.js","src/core/constructor/handler.js","src/core/constructor/index.js","src/core/constructor/separate.js","src/core/create-request/index.js","src/core/create-request/mark-map.js","src/core/create-request/request-timer.js","src/core/create-request/wait.js","src/core/request/handle-fetch.js","src/core/request/index.js","src/reixs.js","src/shared/constants.js","src/shared/utils.js"],"names":[],"mappings":"AAAA;;;ACAA,MAAM,CAAC,OAAP,GAAiB,OAAO,CAAC,aAAD,CAAP,WAAjB;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACttBA;;;;;;;;SAKI,O,GAAU;AACN,MAAA,QAAQ,EAAE,KADJ;AAE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","file":"reixs.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports = require('./src/reixs').default","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","function _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nmodule.exports = _interopRequireWildcard;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","/**\n * The underlying request model\n */\nexport default class {\n    // Request trigger rule configuration\n    _config = {\n        throttle: false,\n        debounce: 0,\n        audit: false,\n        overtime: null\n    }\n\n    // Life cycle function\n    _hook = {\n        tartHook: null,\n        endHook: null,\n        errorHook: null\n    }\n\n    // Data filtering\n    _pipes = {\n        reqPipes: [],\n        resPipes: []\n    }\n\n    // Different stage interceptors\n    _interceptors = {\n        beforeReq: null, \n        afterReq: null, \n        beforeRes: null, \n        afterRes: null\n    }\n\n    // Task queue executed after the request is completed\n    _taskList =[]\n\n    /**\n     * Circular call task\n     * @param {*} data \n     */\n    _execute(data) {\n        const {errorHook} = this._hook\n        if (data !== undefined) {\n            try {\n                this._taskList.forEach(task =>{\n                    task(data)\n                })\n            } catch (error) {\n                errorHook && errorHook(error)\n            }\n        }\n    }\n    \n    /**\n     * Set the request filter pipeline\n     * \n     * @param  {...any} pipes \n     */\n    reqPipes(...pipes) {\n        if (pipes.find(pipe =>typeof pipe !== 'function')) {\n            throw new Error('Pipe must be a function')\n        } else {\n            this._pipes.reqPipes = [...pipes]\n        }\n        return this\n    }\n\n    /**\n     * Set the response filter pipeline\n     * \n     * @param  {...any} pipes \n     */\n    resPipes(...pipes) {\n        if (pipes.find(pipe =>typeof pipe !== 'function')) {\n            throw new Error('Pipe must be a function')\n        } else {\n            this._pipes.resPipes = [...pipes]\n        }\n        return this\n    }\n\n    /**\n     * Set throttle\n     * \n     * @param {number|boolean} settings \n     */\n    throttle(settings) {\n        if (typeof settings === 'number' || settings === false) {\n            this._config.throttle = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Set debounce\n     * \n     * @param {number|boolean} settings \n     */\n    debounce(settings) {\n        if (typeof settings === 'number' || settings === false) {\n            this._config.debounce = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set audit\n     * \n     * @param {number|boolean} settings \n     */\n    audit(settings) {\n        if (typeof settings === 'number' || typeof settings === 'boolean') {\n            this._config.audit = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set overtime\n     * \n     * @param {number|null} time \n     */\n    overtime(time) {\n        if (typeof time === 'number' || time === null) {\n            this._config.overtime = time\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set request interceptor\n     * @param {Function} interceptor \n     */\n    reqInterceptor(interceptor) {\n        if (typeof interceptor === 'function') {\n            if (this._pipes.reqPipes.length) {\n                this._interceptors.afterReq = interceptor\n            } else {\n                this._interceptors.beforeReq = interceptor\n            }\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Set response interceptor\n     * @param {Function} interceptor \n     */\n    resInterceptor(interceptor) {\n        if (typeof interceptor === 'function') {\n            if (this._pipes.resPipes.length) {\n                this._interceptors.afterRes = interceptor\n            } else {\n                this._interceptors.beforeRes = interceptor\n            }\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n\n    /**\n     * Add task\n     * \n     * @param {Function} task \n     */\n    task(task) {\n        if (typeof task === 'function') {\n            this._taskList.push(task)\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n\n    /**\n     * Request to start\n     * \n     * @param {Function} startHook \n     */\n    start(startHook) {\n        if (typeof startHook === 'function') {\n            this._hook.startHook = startHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Request to end\n     * \n     * @param {Function} endHook \n     */\n    end(endHook) {\n        if (typeof endHook === 'function') {\n            this._hook.endHook = endHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Request to error\n     * \n     * @param {Function} errorHook \n     */\n    error(errorHook) {\n        if (typeof errorHook === 'function') {\n            this._hook.errorHook = errorHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n}\n\n","import separate from './separate.js'\n\nexport const Separate = separate","import {dataFiltering} from '../../shared/utils'\nimport {METHOD_TYPES} from '../../shared/constants'\n\nimport createRequest from '../create-request'\nimport * as request from '../request'\n\nimport Handler from './handler'\n\n/**\n *  Separate request object\n */\nclass SeparateHandler  extends Handler {\n    constructor(url, method = 'get', params = null) {\n        super()\n\n        // Initialize the http\n        this._http = {\n            ...this._http,\n            url,\n            params\n        }\n        this.setMethod(method)\n\n        // Create request function\n        this._initRequest()\n    }\n\n    // Multiple requests Shared\n    static global = {\n        globalHeader: {},\n        globalParams: {},\n        reqPipes: [],\n        resPipes: [],\n        beforeReq: null,\n        afterReq: null,\n        beforeRes: null,\n        afterRes: null\n    }\n\n    // Network request information\n    _http = {\n        url: '',\n        method: null,\n        header: {},\n        params: null,\n        cookie: true\n    }\n    \n    /**\n     * Complete request header\n     * \n     * @return {Object} \n     */\n    get requesetHeader() {\n        const {header} = this._http\n        const {globalHeader} = this.constructor.global\n        return {\n            ...globalHeader, \n            ...header\n        }\n    }\n    \n    /**\n     * Complete request parameters\n     * \n     * @param {Object} params \n     */\n    _getParams(params) {\n        const {globalParams} = this.constructor.global\n        return {\n            ...globalParams, \n            ...params\n        }\n    }\n\n    /**\n     * Create request function\n     */\n    _initRequest() {\n        const {_config, _sendRequest, _execute, _hook} = this\n        this.request = createRequest(\n            _config, \n            _sendRequest.bind(this), \n            _execute.bind(this), \n            _hook\n        )\n    }\n\n    /**\n     * Set the request url\n     * \n     * @param {string} url \n     */\n    setUrl(url) {\n        if (typeof url === 'string') {\n            this._http.url = url\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set the request header\n     * \n     * @param {Object} header \n     */\n    setHeader(header) {\n        if (header.constructor === Object) {\n            this._http.header = header\n        } else {\n            throw new Error('Header invalid setting')\n        }\n        return this\n    }\n\n    /**\n     * Set request parameters\n     * \n     * @param {*} params \n     */\n    setParams(params) {\n        this._http.params = params\n        return this\n    }\n    \n    /**\n     * Set whether to carry cookies\n     * \n     * @param {boolean} ifCookie \n     */\n    setCookie(ifCookie) {\n        if (typeof ifCookie === 'boolean') {\n            this._http.cookie = ifCookie\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Set the request method\n     * \n     * @param {string} method \n     */\n    setMethod(method = null) {\n        method = method.toLowerCase()\n        if (METHOD_TYPES.includes(method)) {\n            this._http.method = method\n        } else {\n            throw new Error('Invalid method')\n        }\n        return this\n    }\n    \n    /**\n     * Send the request to the server\n     * \n     * @param {*} params \n     * @param {string} type \n     */\n    async _sendRequest(params = this._http.params, type) {\n        const {url, method, cookie} = this._http\n        const {errorHook} = this._hook\n        const {reqPipes, resPipes} = this._pipes\n        const {beforeReq, afterReq, beforeRes, afterRes} = this._interceptors\n        const {\n            reqPipes: globalReqPipes, \n            resPipes: globalResPipes,\n            beforeReq: globalBeforeReq,\n            afterReq: globalAfterReq,\n            beforeRes: globalBeforeRes,\n            afterRes: globalAfterRes\n        } = this.constructor.global\n        \n        const requestType = type ? type : method\n        const requestParams = requestType === 'push' \n            ? params : this._getParams(params)\n\n        if ((globalBeforeReq && globalBeforeReq(requestParams) === false) \n        || (beforeReq && beforeReq(requestParams) === false)) {\n            return \n        }\n\n        let finalParams\n        try {\n            finalParams = dataFiltering([...globalReqPipes, ...reqPipes], requestParams)\n        } catch (error) {\n            errorHook(error)\n        }\n        \n        if ((globalAfterReq && globalAfterReq(finalParams) === false) \n        || (afterReq && afterReq(finalParams) === false)) {\n            return \n        }\n\n        const data = await request[requestType](\n            url, \n            finalParams,\n            this.requesetHeader,\n            cookie\n        )\n        \n        \n        if ((globalBeforeRes && globalBeforeRes(data) === false) \n        || (beforeRes && beforeRes(data) === false)) {\n            return \n        }\n\n        let finalData\n        try {\n            finalData = dataFiltering([...globalResPipes, ...resPipes], data)\n        } catch (error) {\n            errorHook(error)\n        }\n\n        if ((globalAfterRes && globalAfterRes(finalData) === false) \n        || (afterRes && afterRes(finalData) === false)) {\n            return \n        }\n\n        return finalData\n    }\n}\n\n\n// Bind request category \nMETHOD_TYPES.map(requestType=>{\n    SeparateHandler.prototype[requestType] = function(params) {\n        this.request(params, requestType)\n    }\n})\n \n\nexport default SeparateHandler","import MarkMap from './mark-map'\nimport {ThrottleWait, DebounceWait} from './wait'\nimport requestTimer from './request-timer'\n\n/**\n * The method to create the request\n * \n * @param {Object} config \n * @param {Function} sendRequest \n * @param {Array} execute \n * @param {Object} hook \n */\nexport default function(config, sendRequest, execute, hook) {\n    const markMap = new MarkMap()\n    const throttleWait = new ThrottleWait()\n    const debounceWait = new DebounceWait()\n    return async function(...par) {\n        const {startHook, endHook} = hook\n        const {throttle, debounce, audit, overtime} = config\n        startHook && startHook(...par)\n        let mark\n        if (audit) {\n            mark = markMap.get(audit)\n        }\n        await Promise.all([\n            throttleWait.get(throttle), \n            debounceWait.get(debounce)\n        ])\n        const {timeout, data} = await requestTimer(sendRequest(...par), overtime)\n\n        if (data === undefined) {\n            endHook && endHook()\n            return \n        }\n        // If audit is set, the duplicate request is discarded\n        if (!audit || markMap.test(mark)) {\n            // If the timeout occurs, the task is not processed\n            if (!timeout) {\n                execute(data)\n            }\n            endHook && endHook()\n        }\n    }\n}","\n\n/**\n * Create a signature object\n * \n * @param {symbol} sym \n * @param {number} time \n */\nfunction createSign(sym, time) {\n    const sign = Object.create(null)\n    sign.sym = sym\n    sign.time = time\n    return sign\n}\n\n/**\n * Create a mark object\n * \n * @param {Object} sign \n */\nfunction createMark(sign) {\n    const mark = Object.create(null)\n    mark.sign = sign\n    mark.sym = sign.sym\n    return mark\n}\n\n/**\n * Verify that mark is deprecated\n */\nexport default class {\n    _map = []\n\n    /**\n     * Get mark\n     * @param {number|boolean} audit \n     */\n    get(audit) {\n        const {_map} = this\n        if (audit) {\n            const sym = Symbol()\n            const time = Date.now()\n            let sign\n            if (!_map.length \n                || (time - _map[_map.length - 1].time > audit \n                    && audit !== true)\n            ) {\n                sign = createSign(sym, time)\n                _map.push(sign)\n            } else {\n                sign = _map[_map.length - 1]\n                sign.sym = sym\n                sign.time = time\n            }\n\n            return createMark(sign)\n        }\n        return null\n    }\n\n    /**\n     * Verify the mark\n     * @param {Object} mark \n     */\n    test(mark) {\n        if (mark && mark.sym !== mark.sign.sym) {\n            return false\n        } \n\n        if (mark) {\n            const {_map} = this\n            const index = _map.indexOf(mark.sign)\n            _map.splice(index, 1)\n        }\n        return true\n    }\n}","/**\n * Create delay promise\n * \n * @param {number} time \n */\nfunction createWait(time) {\n    return time === 0 ? Promise.resolve()\n        : new Promise(resolve=>{\n            setTimeout(()=>resolve(), time)\n        })\n}\n\n/**\n * Detect timeout\n * \n * @param {Promise} promise \n * @param {null|number} time \n */\nexport default function requestTimer(promise, time) {\n    const request = promise.then(data=>({\n        timeout: false, \n        data\n    }))\n    const timer = createWait(time).then(()=>({\n        timeout: true, \n        data: null\n    }))\n    return time === null ? request\n        : Promise.race([request, timer])\n}","/**\n * Create wait object\n */\nclass Wait {\n    _timer = null\n\n    /**\n     * Create internal promise\n     * @param {number} time \n     */\n    _createPromise(time) {\n        return time ? new Promise(resolve=>{\n            this._timer =  setTimeout(()=>{ \n                this._timer = null\n                resolve() \n            }, time)\n        }) : Promise.resolve()\n    }\n}\n\n/**\n * Create debounce wait object\n */\nexport class ThrottleWait extends Wait {\n    constructor() {\n        super()\n    }\n\n    /**\n     * get await promise\n     * @param {number} time \n     */\n    get(time) {\n        if (this._timer) {\n            return new Promise(()=>{})\n        }\n        return this._createPromise(time)\n    }\n}\n\n/**\n * Create debounce wait object\n */\nexport class DebounceWait extends Wait {\n    constructor() {\n        super()\n    }\n\n    /**\n     * get await promise\n     * @param {number} time \n     */\n    get(time) {\n        if (this._timer) {\n            clearTimeout(this._timer)\n            this._timer = null\n        }\n        return this._createPromise(time)\n    }\n}","\n/**\n * Check for success\n * \n * @param {Object} response \n */\nfunction checkStatus(response) {\n    if (response.status >= 200 && response.status < 300) {\n        const contentType = response.headers.get('content-type')\n        if (contentType && contentType.includes('application/json')) {\n            return response.json()\n        } else {\n            return response.text()\n        }\n    } else {\n        throw new Error()\n    }\n}\n\n/**\n * Handle fetch\n * \n * @param {Object} promise \n */\nexport default function handleFetch(promise) {\n    return promise\n        .then(response => checkStatus(response))\n        .catch(error => {\n            throw error\n        })\n}","import {CONTENT_TYPE} from '../../shared/constants'\nimport handleFetch from './handle-fetch'\n\n\n/**\n * Query String Parameters\n * \n * @param {string} url \n * @param {*} params \n * @param {Object} headers \n * @param {boolean} cookie \n */\nexport function get(url, params, headers, cookie) {\n    url = new URL(url)\n    Object.keys(params)\n        .forEach(key => url.searchParams.append(key, params[key]))\n    const promise = fetch(url, {\n        method: 'GET',\n        headers: {\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Dynamic Router\n * \n * @param {string} url \n * @param {*} params \n * @param {Object} headers \n * @param {boolean} cookie \n */\nexport function push(url, params, headers, cookie) {\n    url = new URL(url)\n    url.pathname += `/${params}`\n    const promise = fetch(url, {\n        method: 'GET',\n        headers: {\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Request Payload\n * \n * @param {string} url \n * @param {*} params \n * @param {Object} headers \n * @param {boolean} cookie \n */\nexport function post(url, params, headers, cookie) {\n    url = new URL(url)\n    const promise = fetch(url, {\n        method: 'POST',\n        body: JSON.stringify(params),\n        headers: {\n            'Content-type': CONTENT_TYPE['JSON'],\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Form Data\n * \n * @param {string} url \n * @param {*} params \n * @param {Object} headers \n * @param {boolean} cookie \n */\nexport function form(url, params, headers, cookie) {\n    url = new URL(url)\n    const promise = fetch(url, {\n        method: 'POST',\n        body: JSON.stringify(params),\n        headers: {\n            'Content-type': CONTENT_TYPE['FORM'],\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n","import {Separate} from './core/constructor'\n\n/**\n * Create reixs \n * \n * @param {string} url \n * @param {string} method\n * @param {*} params  \n */\nfunction createInstance(url, method, params) {\n    return new Proxy(new Separate(url, method, params), {\n        set() {\n            throw new Error('Overwriting any attributes is not allowed')\n        }\n    })\n}\n\n/**\n * Set pipe \n * \n * @param {string} name \n * @param  {...any} funList \n */\nfunction setPipes(name, ...funList) {\n    funList.forEach(fn=>{\n        if (typeof fn !== 'function') {\n            throw new Error('Invalid type')\n        }\n    })\n    Separate.global[name] = [...funList]\n}\n\n/**\n * Set Interceptor\n * \n * @param {string} name \n * @param {Function} fun \n */\nfunction setInterceptor(name, fun) {\n    if (typeof fn === 'function') {\n        Separate.global[name] = fun\n    } else {\n        throw new Error('Invalid type')\n    }\n}\n\nexport default new Proxy(createInstance, {\n    get(target, property) {\n        switch (property) {\n        // Replaced by browserify-versionify transform\n        case 'version':\n            return '__VERSION__'\n        // Set request and response pipe\n        case 'reqPipes':\n        case 'resPipes':\n            return setPipes.bind(null, property)\n        // Set request and response interceptor\n        case 'beforeReq':\n        case 'afterReq':\n        case 'beforeRes':\n        case 'afterRes':\n            return setInterceptor.bind(null, property)\n        }\n    },\n    set(target, property, value) {\n        switch (property) {\n        case 'globalHeader':\n        case 'globalParams':\n            if (value.constructor === Object) {\n                Separate.global[property] = value\n            } else {\n                throw new Error('Invalid type')\n            }\n        }\n    }\n})\n\n","export const METHOD_TYPES = [\n    'get',\n    'post',\n    'form',\n    'push'\n]\n\nexport const CONTENT_TYPE = {\n    JSON: 'application/json;charset=UTF-8',\n    FORM: 'application/x-www-form-urlencoded; charset=UTF-8'\n}","/**\n * Data processing\n *\n * @param {*} data \n */\nexport function dataFiltering(pipes, data) {\n    const newData = [data, ...pipes].reduce((prev, cur)=>cur(prev))\n    return newData\n}"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwic3JjL2NvcmUvY29uc3RydWN0b3IvaGFuZGxlci5qcyIsInNyYy9jb3JlL2NvbnN0cnVjdG9yL2luZGV4LmpzIiwic3JjL2NvcmUvY29uc3RydWN0b3Ivc2VwYXJhdGUuanMiLCJzcmMvY29yZS9jcmVhdGUtcmVxdWVzdC9pbmRleC5qcyIsInNyYy9jb3JlL2NyZWF0ZS1yZXF1ZXN0L21hcmstbWFwLmpzIiwic3JjL2NvcmUvY3JlYXRlLXJlcXVlc3QvcmVxdWVzdC10aW1lci5qcyIsInNyYy9jb3JlL2NyZWF0ZS1yZXF1ZXN0L3dhaXQuanMiLCJzcmMvY29yZS9yZXF1ZXN0L2hhbmRsZS1mZXRjaC5qcyIsInNyYy9jb3JlL3JlcXVlc3QvaW5kZXguanMiLCJzcmMvcmVpeHMuanMiLCJzcmMvc2hhcmVkL2NvbnN0YW50cy5qcyIsInNyYy9zaGFyZWQvdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLE9BQU8sQ0FBQyxhQUFELENBQVAsV0FBakI7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdHRCQTs7Ozs7Ozs7U0FLSSxPLEdBQVU7QUFDTixNQUFBLFFBQVEsRUFBRSxLQURKO0FBRU4sTUFBQSxRQUFRLEVBQUUsQ0FGSjtBQUdOLE1BQUEsS0FBSyxFQUFFLEtBSEQ7QUFJTixNQUFBLFFB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LENBQVUsY0FBVixDQUFOO0FBQ0g7O0FBUEw7QUFTSDtBQTVCb0MsQ0FBMUIsQzs7Ozs7Ozs7Ozs7QUM5Q1IsSUFBTSxZQUFZLEdBQUcsQ0FDeEIsS0FEd0IsRUFFeEIsTUFGd0IsRUFHeEIsTUFId0IsRUFJeEIsTUFKd0IsQ0FBckI7O0FBT0EsSUFBTSxZQUFZLEdBQUc7QUFDeEIsRUFBQSxJQUFJLEVBQUUsZ0NBRGtCO0FBRXhCLEVBQUEsSUFBSSxFQUFFO0FBRmtCLENBQXJCOzs7Ozs7Ozs7Ozs7Ozs7QUNQUDs7Ozs7QUFLTyxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsRUFBOEIsSUFBOUIsRUFBb0M7QUFDdkMsTUFBTSxPQUFPLEdBQUcsQ0FBQyxJQUFELDZDQUFVLEtBQVYsR0FBaUIsTUFBakIsQ0FBd0IsVUFBQyxJQUFELEVBQU8sR0FBUDtBQUFBLFdBQWEsR0FBRyxDQUFDLElBQUQsQ0FBaEI7QUFBQSxHQUF4QixDQUFoQjtBQUNBLFNBQU8sT0FBUDtBQUNIIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy9yZWl4cycpLmRlZmF1bHQiLCJmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlczsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5ld09iaiA9IHt9O1xuXG4gICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307XG5cbiAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcbiAgICByZXR1cm4gbmV3T2JqO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyIsImZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZjIgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mMihvYmopOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZjIoU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsIi8qKlxuICogVGhlIHVuZGVybHlpbmcgcmVxdWVzdCBtb2RlbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gICAgLy8gUmVxdWVzdCB0cmlnZ2VyIHJ1bGUgY29uZmlndXJhdGlvblxuICAgIF9jb25maWcgPSB7XG4gICAgICAgIHRocm90dGxlOiBmYWxzZSxcbiAgICAgICAgZGVib3VuY2U6IDAsXG4gICAgICAgIGF1ZGl0OiBmYWxzZSxcbiAgICAgICAgb3ZlcnRpbWU6IG51bGxcbiAgICB9XG5cbiAgICAvLyBMaWZlIGN5Y2xlIGZ1bmN0aW9uXG4gICAgX2hvb2sgPSB7XG4gICAgICAgIHRhcnRIb29rOiBudWxsLFxuICAgICAgICBlbmRIb29rOiBudWxsLFxuICAgICAgICBlcnJvckhvb2s6IG51bGxcbiAgICB9XG5cbiAgICAvLyBEYXRhIGZpbHRlcmluZ1xuICAgIF9waXBlcyA9IHtcbiAgICAgICAgcmVxUGlwZXM6IFtdLFxuICAgICAgICByZXNQaXBlczogW11cbiAgICB9XG5cbiAgICAvLyBEaWZmZXJlbnQgc3RhZ2UgaW50ZXJjZXB0b3JzXG4gICAgX2ludGVyY2VwdG9ycyA9IHtcbiAgICAgICAgYmVmb3JlUmVxOiBudWxsLCBcbiAgICAgICAgYWZ0ZXJSZXE6IG51bGwsIFxuICAgICAgICBiZWZvcmVSZXM6IG51bGwsIFxuICAgICAgICBhZnRlclJlczogbnVsbFxuICAgIH1cblxuICAgIC8vIFRhc2sgcXVldWUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIHJlcXVlc3QgaXMgY29tcGxldGVkXG4gICAgX3Rhc2tMaXN0ID1bXVxuXG4gICAgLyoqXG4gICAgICogQ2lyY3VsYXIgY2FsbCB0YXNrXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFxuICAgICAqL1xuICAgIF9leGVjdXRlKGRhdGEpIHtcbiAgICAgICAgY29uc3Qge2Vycm9ySG9va30gPSB0aGlzLl9ob29rXG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFza0xpc3QuZm9yRWFjaCh0YXNrID0+e1xuICAgICAgICAgICAgICAgICAgICB0YXNrKGRhdGEpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JIb29rICYmIGVycm9ySG9vayhlcnJvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHJlcXVlc3QgZmlsdGVyIHBpcGVsaW5lXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBwaXBlcyBcbiAgICAgKi9cbiAgICByZXFQaXBlcyguLi5waXBlcykge1xuICAgICAgICBpZiAocGlwZXMuZmluZChwaXBlID0+dHlwZW9mIHBpcGUgIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpcGUgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BpcGVzLnJlcVBpcGVzID0gWy4uLnBpcGVzXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXNwb25zZSBmaWx0ZXIgcGlwZWxpbmVcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IHBpcGVzIFxuICAgICAqL1xuICAgIHJlc1BpcGVzKC4uLnBpcGVzKSB7XG4gICAgICAgIGlmIChwaXBlcy5maW5kKHBpcGUgPT50eXBlb2YgcGlwZSAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGlwZSBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGlwZXMucmVzUGlwZXMgPSBbLi4ucGlwZXNdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhyb3R0bGVcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcnxib29sZWFufSBzZXR0aW5ncyBcbiAgICAgKi9cbiAgICB0aHJvdHRsZShzZXR0aW5ncykge1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnbnVtYmVyJyB8fCBzZXR0aW5ncyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy50aHJvdHRsZSA9IHNldHRpbmdzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGVib3VuY2VcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcnxib29sZWFufSBzZXR0aW5ncyBcbiAgICAgKi9cbiAgICBkZWJvdW5jZShzZXR0aW5ncykge1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnbnVtYmVyJyB8fCBzZXR0aW5ncyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5kZWJvdW5jZSA9IHNldHRpbmdzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IGF1ZGl0XG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ8Ym9vbGVhbn0gc2V0dGluZ3MgXG4gICAgICovXG4gICAgYXVkaXQoc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHNldHRpbmdzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5hdWRpdCA9IHNldHRpbmdzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IG92ZXJ0aW1lXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gdGltZSBcbiAgICAgKi9cbiAgICBvdmVydGltZSh0aW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGltZSA9PT0gJ251bWJlcicgfHwgdGltZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLm92ZXJ0aW1lID0gdGltZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFNldCByZXF1ZXN0IGludGVyY2VwdG9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgXG4gICAgICovXG4gICAgcmVxSW50ZXJjZXB0b3IoaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BpcGVzLnJlcVBpcGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVyY2VwdG9ycy5hZnRlclJlcSA9IGludGVyY2VwdG9yXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVyY2VwdG9ycy5iZWZvcmVSZXEgPSBpbnRlcmNlcHRvclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBTZXQgcmVzcG9uc2UgaW50ZXJjZXB0b3JcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBcbiAgICAgKi9cbiAgICByZXNJbnRlcmNlcHRvcihpbnRlcmNlcHRvcikge1xuICAgICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGlwZXMucmVzUGlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJjZXB0b3JzLmFmdGVyUmVzID0gaW50ZXJjZXB0b3JcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJjZXB0b3JzLmJlZm9yZVJlcyA9IGludGVyY2VwdG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRhc2tcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0YXNrIFxuICAgICAqL1xuICAgIHRhc2sodGFzaykge1xuICAgICAgICBpZiAodHlwZW9mIHRhc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rhc2tMaXN0LnB1c2godGFzaylcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHRvIHN0YXJ0XG4gICAgICogXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RhcnRIb29rIFxuICAgICAqL1xuICAgIHN0YXJ0KHN0YXJ0SG9vaykge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXJ0SG9vayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5faG9vay5zdGFydEhvb2sgPSBzdGFydEhvb2tcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0byBlbmRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmRIb29rIFxuICAgICAqL1xuICAgIGVuZChlbmRIb29rKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kSG9vayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5faG9vay5lbmRIb29rID0gZW5kSG9va1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHRvIGVycm9yXG4gICAgICogXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3JIb29rIFxuICAgICAqL1xuICAgIGVycm9yKGVycm9ySG9vaykge1xuICAgICAgICBpZiAodHlwZW9mIGVycm9ySG9vayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5faG9vay5lcnJvckhvb2sgPSBlcnJvckhvb2tcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsImltcG9ydCBzZXBhcmF0ZSBmcm9tICcuL3NlcGFyYXRlLmpzJ1xuXG5leHBvcnQgY29uc3QgU2VwYXJhdGUgPSBzZXBhcmF0ZSIsImltcG9ydCB7ZGF0YUZpbHRlcmluZ30gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzJ1xuaW1wb3J0IHtNRVRIT0RfVFlQRVN9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMnXG5cbmltcG9ydCBjcmVhdGVSZXF1ZXN0IGZyb20gJy4uL2NyZWF0ZS1yZXF1ZXN0J1xuaW1wb3J0ICogYXMgcmVxdWVzdCBmcm9tICcuLi9yZXF1ZXN0J1xuXG5pbXBvcnQgSGFuZGxlciBmcm9tICcuL2hhbmRsZXInXG5cbi8qKlxuICogIFNlcGFyYXRlIHJlcXVlc3Qgb2JqZWN0XG4gKi9cbmNsYXNzIFNlcGFyYXRlSGFuZGxlciAgZXh0ZW5kcyBIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG1ldGhvZCA9ICdnZXQnLCBwYXJhbXMgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKClcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBodHRwXG4gICAgICAgIHRoaXMuX2h0dHAgPSB7XG4gICAgICAgICAgICAuLi50aGlzLl9odHRwLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRNZXRob2QobWV0aG9kKVxuXG4gICAgICAgIC8vIENyZWF0ZSByZXF1ZXN0IGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX2luaXRSZXF1ZXN0KClcbiAgICB9XG5cbiAgICAvLyBNdWx0aXBsZSByZXF1ZXN0cyBTaGFyZWRcbiAgICBzdGF0aWMgZ2xvYmFsID0ge1xuICAgICAgICBnbG9iYWxIZWFkZXI6IHt9LFxuICAgICAgICBnbG9iYWxQYXJhbXM6IHt9LFxuICAgICAgICByZXFQaXBlczogW10sXG4gICAgICAgIHJlc1BpcGVzOiBbXSxcbiAgICAgICAgYmVmb3JlUmVxOiBudWxsLFxuICAgICAgICBhZnRlclJlcTogbnVsbCxcbiAgICAgICAgYmVmb3JlUmVzOiBudWxsLFxuICAgICAgICBhZnRlclJlczogbnVsbFxuICAgIH1cblxuICAgIC8vIE5ldHdvcmsgcmVxdWVzdCBpbmZvcm1hdGlvblxuICAgIF9odHRwID0ge1xuICAgICAgICB1cmw6ICcnLFxuICAgICAgICBtZXRob2Q6IG51bGwsXG4gICAgICAgIGhlYWRlcjoge30sXG4gICAgICAgIHBhcmFtczogbnVsbCxcbiAgICAgICAgY29va2llOiB0cnVlXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIHJlcXVlc3QgaGVhZGVyXG4gICAgICogXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBcbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzZXRIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IHtoZWFkZXJ9ID0gdGhpcy5faHR0cFxuICAgICAgICBjb25zdCB7Z2xvYmFsSGVhZGVyfSA9IHRoaXMuY29uc3RydWN0b3IuZ2xvYmFsXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nbG9iYWxIZWFkZXIsIFxuICAgICAgICAgICAgLi4uaGVhZGVyXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQ29tcGxldGUgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBcbiAgICAgKi9cbiAgICBfZ2V0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7Z2xvYmFsUGFyYW1zfSA9IHRoaXMuY29uc3RydWN0b3IuZ2xvYmFsXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nbG9iYWxQYXJhbXMsIFxuICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcmVxdWVzdCBmdW5jdGlvblxuICAgICAqL1xuICAgIF9pbml0UmVxdWVzdCgpIHtcbiAgICAgICAgY29uc3Qge19jb25maWcsIF9zZW5kUmVxdWVzdCwgX2V4ZWN1dGUsIF9ob29rfSA9IHRoaXNcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChcbiAgICAgICAgICAgIF9jb25maWcsIFxuICAgICAgICAgICAgX3NlbmRSZXF1ZXN0LmJpbmQodGhpcyksIFxuICAgICAgICAgICAgX2V4ZWN1dGUuYmluZCh0aGlzKSwgXG4gICAgICAgICAgICBfaG9va1xuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IHVybFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgXG4gICAgICovXG4gICAgc2V0VXJsKHVybCkge1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAudXJsID0gdXJsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IGhlYWRlclxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXIgXG4gICAgICovXG4gICAgc2V0SGVhZGVyKGhlYWRlcikge1xuICAgICAgICBpZiAoaGVhZGVyLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAuaGVhZGVyID0gaGVhZGVyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYWRlciBpbnZhbGlkIHNldHRpbmcnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHJlcXVlc3QgcGFyYW1ldGVyc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gcGFyYW1zIFxuICAgICAqL1xuICAgIHNldFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5faHR0cC5wYXJhbXMgPSBwYXJhbXNcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdG8gY2FycnkgY29va2llc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWZDb29raWUgXG4gICAgICovXG4gICAgc2V0Q29va2llKGlmQ29va2llKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWZDb29raWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5faHR0cC5jb29raWUgPSBpZkNvb2tpZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IG1ldGhvZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgXG4gICAgICovXG4gICAgc2V0TWV0aG9kKG1ldGhvZCA9IG51bGwpIHtcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKClcbiAgICAgICAgaWYgKE1FVEhPRF9UWVBFUy5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzLl9odHRwLm1ldGhvZCA9IG1ldGhvZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCcpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgcmVxdWVzdCB0byB0aGUgc2VydmVyXG4gICAgICogXG4gICAgICogQHBhcmFtIHsqfSBwYXJhbXMgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXG4gICAgICovXG4gICAgYXN5bmMgX3NlbmRSZXF1ZXN0KHBhcmFtcyA9IHRoaXMuX2h0dHAucGFyYW1zLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHt1cmwsIG1ldGhvZCwgY29va2llfSA9IHRoaXMuX2h0dHBcbiAgICAgICAgY29uc3Qge2Vycm9ySG9va30gPSB0aGlzLl9ob29rXG4gICAgICAgIGNvbnN0IHtyZXFQaXBlcywgcmVzUGlwZXN9ID0gdGhpcy5fcGlwZXNcbiAgICAgICAgY29uc3Qge2JlZm9yZVJlcSwgYWZ0ZXJSZXEsIGJlZm9yZVJlcywgYWZ0ZXJSZXN9ID0gdGhpcy5faW50ZXJjZXB0b3JzXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHJlcVBpcGVzOiBnbG9iYWxSZXFQaXBlcywgXG4gICAgICAgICAgICByZXNQaXBlczogZ2xvYmFsUmVzUGlwZXMsXG4gICAgICAgICAgICBiZWZvcmVSZXE6IGdsb2JhbEJlZm9yZVJlcSxcbiAgICAgICAgICAgIGFmdGVyUmVxOiBnbG9iYWxBZnRlclJlcSxcbiAgICAgICAgICAgIGJlZm9yZVJlczogZ2xvYmFsQmVmb3JlUmVzLFxuICAgICAgICAgICAgYWZ0ZXJSZXM6IGdsb2JhbEFmdGVyUmVzXG4gICAgICAgIH0gPSB0aGlzLmNvbnN0cnVjdG9yLmdsb2JhbFxuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVxdWVzdFR5cGUgPSB0eXBlID8gdHlwZSA6IG1ldGhvZFxuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gcmVxdWVzdFR5cGUgPT09ICdwdXNoJyBcbiAgICAgICAgICAgID8gcGFyYW1zIDogdGhpcy5fZ2V0UGFyYW1zKHBhcmFtcylcblxuICAgICAgICBpZiAoKGdsb2JhbEJlZm9yZVJlcSAmJiBnbG9iYWxCZWZvcmVSZXEocmVxdWVzdFBhcmFtcykgPT09IGZhbHNlKSBcbiAgICAgICAgfHwgKGJlZm9yZVJlcSAmJiBiZWZvcmVSZXEocmVxdWVzdFBhcmFtcykgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZpbmFsUGFyYW1zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5hbFBhcmFtcyA9IGRhdGFGaWx0ZXJpbmcoWy4uLmdsb2JhbFJlcVBpcGVzLCAuLi5yZXFQaXBlc10sIHJlcXVlc3RQYXJhbXMpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvckhvb2soZXJyb3IpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICgoZ2xvYmFsQWZ0ZXJSZXEgJiYgZ2xvYmFsQWZ0ZXJSZXEoZmluYWxQYXJhbXMpID09PSBmYWxzZSkgXG4gICAgICAgIHx8IChhZnRlclJlcSAmJiBhZnRlclJlcShmaW5hbFBhcmFtcykgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcXVlc3RbcmVxdWVzdFR5cGVdKFxuICAgICAgICAgICAgdXJsLCBcbiAgICAgICAgICAgIGZpbmFsUGFyYW1zLFxuICAgICAgICAgICAgdGhpcy5yZXF1ZXNldEhlYWRlcixcbiAgICAgICAgICAgIGNvb2tpZVxuICAgICAgICApXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYgKChnbG9iYWxCZWZvcmVSZXMgJiYgZ2xvYmFsQmVmb3JlUmVzKGRhdGEpID09PSBmYWxzZSkgXG4gICAgICAgIHx8IChiZWZvcmVSZXMgJiYgYmVmb3JlUmVzKGRhdGEpID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaW5hbERhdGFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmFsRGF0YSA9IGRhdGFGaWx0ZXJpbmcoWy4uLmdsb2JhbFJlc1BpcGVzLCAuLi5yZXNQaXBlc10sIGRhdGEpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvckhvb2soZXJyb3IpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGdsb2JhbEFmdGVyUmVzICYmIGdsb2JhbEFmdGVyUmVzKGZpbmFsRGF0YSkgPT09IGZhbHNlKSBcbiAgICAgICAgfHwgKGFmdGVyUmVzICYmIGFmdGVyUmVzKGZpbmFsRGF0YSkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbmFsRGF0YVxuICAgIH1cbn1cblxuXG4vLyBCaW5kIHJlcXVlc3QgY2F0ZWdvcnkgXG5NRVRIT0RfVFlQRVMubWFwKHJlcXVlc3RUeXBlPT57XG4gICAgU2VwYXJhdGVIYW5kbGVyLnByb3RvdHlwZVtyZXF1ZXN0VHlwZV0gPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KHBhcmFtcywgcmVxdWVzdFR5cGUpXG4gICAgfVxufSlcbiBcblxuZXhwb3J0IGRlZmF1bHQgU2VwYXJhdGVIYW5kbGVyIiwiaW1wb3J0IE1hcmtNYXAgZnJvbSAnLi9tYXJrLW1hcCdcbmltcG9ydCB7VGhyb3R0bGVXYWl0LCBEZWJvdW5jZVdhaXR9IGZyb20gJy4vd2FpdCdcbmltcG9ydCByZXF1ZXN0VGltZXIgZnJvbSAnLi9yZXF1ZXN0LXRpbWVyJ1xuXG4vKipcbiAqIFRoZSBtZXRob2QgdG8gY3JlYXRlIHRoZSByZXF1ZXN0XG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZW5kUmVxdWVzdCBcbiAqIEBwYXJhbSB7QXJyYXl9IGV4ZWN1dGUgXG4gKiBAcGFyYW0ge09iamVjdH0gaG9vayBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29uZmlnLCBzZW5kUmVxdWVzdCwgZXhlY3V0ZSwgaG9vaykge1xuICAgIGNvbnN0IG1hcmtNYXAgPSBuZXcgTWFya01hcCgpXG4gICAgY29uc3QgdGhyb3R0bGVXYWl0ID0gbmV3IFRocm90dGxlV2FpdCgpXG4gICAgY29uc3QgZGVib3VuY2VXYWl0ID0gbmV3IERlYm91bmNlV2FpdCgpXG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKC4uLnBhcikge1xuICAgICAgICBjb25zdCB7c3RhcnRIb29rLCBlbmRIb29rfSA9IGhvb2tcbiAgICAgICAgY29uc3Qge3Rocm90dGxlLCBkZWJvdW5jZSwgYXVkaXQsIG92ZXJ0aW1lfSA9IGNvbmZpZ1xuICAgICAgICBzdGFydEhvb2sgJiYgc3RhcnRIb29rKC4uLnBhcilcbiAgICAgICAgbGV0IG1hcmtcbiAgICAgICAgaWYgKGF1ZGl0KSB7XG4gICAgICAgICAgICBtYXJrID0gbWFya01hcC5nZXQoYXVkaXQpXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhyb3R0bGVXYWl0LmdldCh0aHJvdHRsZSksIFxuICAgICAgICAgICAgZGVib3VuY2VXYWl0LmdldChkZWJvdW5jZSlcbiAgICAgICAgXSlcbiAgICAgICAgY29uc3Qge3RpbWVvdXQsIGRhdGF9ID0gYXdhaXQgcmVxdWVzdFRpbWVyKHNlbmRSZXF1ZXN0KC4uLnBhciksIG92ZXJ0aW1lKVxuXG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuZEhvb2sgJiYgZW5kSG9vaygpXG4gICAgICAgICAgICByZXR1cm4gXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYXVkaXQgaXMgc2V0LCB0aGUgZHVwbGljYXRlIHJlcXVlc3QgaXMgZGlzY2FyZGVkXG4gICAgICAgIGlmICghYXVkaXQgfHwgbWFya01hcC50ZXN0KG1hcmspKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdGltZW91dCBvY2N1cnMsIHRoZSB0YXNrIGlzIG5vdCBwcm9jZXNzZWRcbiAgICAgICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGUoZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZEhvb2sgJiYgZW5kSG9vaygpXG4gICAgICAgIH1cbiAgICB9XG59IiwiXG5cbi8qKlxuICogQ3JlYXRlIGEgc2lnbmF0dXJlIG9iamVjdFxuICogXG4gKiBAcGFyYW0ge3N5bWJvbH0gc3ltIFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNpZ24oc3ltLCB0aW1lKSB7XG4gICAgY29uc3Qgc2lnbiA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICBzaWduLnN5bSA9IHN5bVxuICAgIHNpZ24udGltZSA9IHRpbWVcbiAgICByZXR1cm4gc2lnblxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG1hcmsgb2JqZWN0XG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaWduIFxuICovXG5mdW5jdGlvbiBjcmVhdGVNYXJrKHNpZ24pIHtcbiAgICBjb25zdCBtYXJrID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIG1hcmsuc2lnbiA9IHNpZ25cbiAgICBtYXJrLnN5bSA9IHNpZ24uc3ltXG4gICAgcmV0dXJuIG1hcmtcbn1cblxuLyoqXG4gKiBWZXJpZnkgdGhhdCBtYXJrIGlzIGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuICAgIF9tYXAgPSBbXVxuXG4gICAgLyoqXG4gICAgICogR2V0IG1hcmtcbiAgICAgKiBAcGFyYW0ge251bWJlcnxib29sZWFufSBhdWRpdCBcbiAgICAgKi9cbiAgICBnZXQoYXVkaXQpIHtcbiAgICAgICAgY29uc3Qge19tYXB9ID0gdGhpc1xuICAgICAgICBpZiAoYXVkaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN5bSA9IFN5bWJvbCgpXG4gICAgICAgICAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKVxuICAgICAgICAgICAgbGV0IHNpZ25cbiAgICAgICAgICAgIGlmICghX21hcC5sZW5ndGggXG4gICAgICAgICAgICAgICAgfHwgKHRpbWUgLSBfbWFwW19tYXAubGVuZ3RoIC0gMV0udGltZSA+IGF1ZGl0IFxuICAgICAgICAgICAgICAgICAgICAmJiBhdWRpdCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNpZ24gPSBjcmVhdGVTaWduKHN5bSwgdGltZSlcbiAgICAgICAgICAgICAgICBfbWFwLnB1c2goc2lnbilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IF9tYXBbX21hcC5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgIHNpZ24uc3ltID0gc3ltXG4gICAgICAgICAgICAgICAgc2lnbi50aW1lID0gdGltZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTWFyayhzaWduKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHRoZSBtYXJrXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcmsgXG4gICAgICovXG4gICAgdGVzdChtYXJrKSB7XG4gICAgICAgIGlmIChtYXJrICYmIG1hcmsuc3ltICE9PSBtYXJrLnNpZ24uc3ltKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBcblxuICAgICAgICBpZiAobWFyaykge1xuICAgICAgICAgICAgY29uc3Qge19tYXB9ID0gdGhpc1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBfbWFwLmluZGV4T2YobWFyay5zaWduKVxuICAgICAgICAgICAgX21hcC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG59IiwiLyoqXG4gKiBDcmVhdGUgZGVsYXkgcHJvbWlzZVxuICogXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV2FpdCh0aW1lKSB7XG4gICAgcmV0dXJuIHRpbWUgPT09IDAgPyBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICA6IG5ldyBQcm9taXNlKHJlc29sdmU9PntcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PnJlc29sdmUoKSwgdGltZSlcbiAgICAgICAgfSlcbn1cblxuLyoqXG4gKiBEZXRlY3QgdGltZW91dFxuICogXG4gKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgXG4gKiBAcGFyYW0ge251bGx8bnVtYmVyfSB0aW1lIFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXF1ZXN0VGltZXIocHJvbWlzZSwgdGltZSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBwcm9taXNlLnRoZW4oZGF0YT0+KHtcbiAgICAgICAgdGltZW91dDogZmFsc2UsIFxuICAgICAgICBkYXRhXG4gICAgfSkpXG4gICAgY29uc3QgdGltZXIgPSBjcmVhdGVXYWl0KHRpbWUpLnRoZW4oKCk9Pih7XG4gICAgICAgIHRpbWVvdXQ6IHRydWUsIFxuICAgICAgICBkYXRhOiBudWxsXG4gICAgfSkpXG4gICAgcmV0dXJuIHRpbWUgPT09IG51bGwgPyByZXF1ZXN0XG4gICAgICAgIDogUHJvbWlzZS5yYWNlKFtyZXF1ZXN0LCB0aW1lcl0pXG59IiwiLyoqXG4gKiBDcmVhdGUgd2FpdCBvYmplY3RcbiAqL1xuY2xhc3MgV2FpdCB7XG4gICAgX3RpbWVyID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGludGVybmFsIHByb21pc2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBcbiAgICAgKi9cbiAgICBfY3JlYXRlUHJvbWlzZSh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aW1lID8gbmV3IFByb21pc2UocmVzb2x2ZT0+e1xuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSAgc2V0VGltZW91dCgoKT0+eyBcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IG51bGxcbiAgICAgICAgICAgICAgICByZXNvbHZlKCkgXG4gICAgICAgICAgICB9LCB0aW1lKVxuICAgICAgICB9KSA6IFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBkZWJvdW5jZSB3YWl0IG9iamVjdFxuICovXG5leHBvcnQgY2xhc3MgVGhyb3R0bGVXYWl0IGV4dGVuZHMgV2FpdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYXdhaXQgcHJvbWlzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFxuICAgICAqL1xuICAgIGdldCh0aW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlUHJvbWlzZSh0aW1lKVxuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgZGVib3VuY2Ugd2FpdCBvYmplY3RcbiAqL1xuZXhwb3J0IGNsYXNzIERlYm91bmNlV2FpdCBleHRlbmRzIFdhaXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGF3YWl0IHByb21pc2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBcbiAgICAgKi9cbiAgICBnZXQodGltZSkge1xuICAgICAgICBpZiAodGhpcy5fdGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcilcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQcm9taXNlKHRpbWUpXG4gICAgfVxufSIsIlxuLyoqXG4gKiBDaGVjayBmb3Igc3VjY2Vzc1xuICogXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU3RhdHVzKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpXG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICAgIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgZmV0Y2hcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IHByb21pc2UgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhhbmRsZUZldGNoKHByb21pc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiBjaGVja1N0YXR1cyhyZXNwb25zZSkpXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9KVxufSIsImltcG9ydCB7Q09OVEVOVF9UWVBFfSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzJ1xuaW1wb3J0IGhhbmRsZUZldGNoIGZyb20gJy4vaGFuZGxlLWZldGNoJ1xuXG5cbi8qKlxuICogUXVlcnkgU3RyaW5nIFBhcmFtZXRlcnNcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBcbiAqIEBwYXJhbSB7Kn0gcGFyYW1zIFxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvb2tpZSBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldCh1cmwsIHBhcmFtcywgaGVhZGVycywgY29va2llKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgT2JqZWN0LmtleXMocGFyYW1zKVxuICAgICAgICAuZm9yRWFjaChrZXkgPT4gdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBwYXJhbXNba2V5XSkpXG4gICAgY29uc3QgcHJvbWlzZSA9IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiBjb29raWUgPyAnaW5jbHVkZScgOiAnb21pdCdcbiAgICB9KVxuICAgIHJldHVybiBoYW5kbGVGZXRjaChwcm9taXNlKVxufVxuXG4vKipcbiAqIER5bmFtaWMgUm91dGVyXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgXG4gKiBAcGFyYW0geyp9IHBhcmFtcyBcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIFxuICogQHBhcmFtIHtib29sZWFufSBjb29raWUgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoKHVybCwgcGFyYW1zLCBoZWFkZXJzLCBjb29raWUpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybClcbiAgICB1cmwucGF0aG5hbWUgKz0gYC8ke3BhcmFtc31gXG4gICAgY29uc3QgcHJvbWlzZSA9IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiBjb29raWUgPyAnaW5jbHVkZScgOiAnb21pdCdcbiAgICB9KVxuICAgIHJldHVybiBoYW5kbGVGZXRjaChwcm9taXNlKVxufVxuXG4vKipcbiAqIFJlcXVlc3QgUGF5bG9hZFxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFxuICogQHBhcmFtIHsqfSBwYXJhbXMgXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVycyBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29va2llIFxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9zdCh1cmwsIHBhcmFtcywgaGVhZGVycywgY29va2llKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgY29uc3QgcHJvbWlzZSA9IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtdHlwZSc6IENPTlRFTlRfVFlQRVsnSlNPTiddLFxuICAgICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogY29va2llID8gJ2luY2x1ZGUnIDogJ29taXQnXG4gICAgfSlcbiAgICByZXR1cm4gaGFuZGxlRmV0Y2gocHJvbWlzZSlcbn1cblxuLyoqXG4gKiBGb3JtIERhdGFcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBcbiAqIEBwYXJhbSB7Kn0gcGFyYW1zIFxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvb2tpZSBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm0odXJsLCBwYXJhbXMsIGhlYWRlcnMsIGNvb2tpZSkge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKVxuICAgIGNvbnN0IHByb21pc2UgPSBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcmFtcyksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LXR5cGUnOiBDT05URU5UX1RZUEVbJ0ZPUk0nXSxcbiAgICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgY3JlZGVudGlhbHM6IGNvb2tpZSA/ICdpbmNsdWRlJyA6ICdvbWl0J1xuICAgIH0pXG4gICAgcmV0dXJuIGhhbmRsZUZldGNoKHByb21pc2UpXG59XG4iLCJpbXBvcnQge1NlcGFyYXRlfSBmcm9tICcuL2NvcmUvY29uc3RydWN0b3InXG5cbi8qKlxuICogQ3JlYXRlIHJlaXhzIFxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHsqfSBwYXJhbXMgIFxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh1cmwsIG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eShuZXcgU2VwYXJhdGUodXJsLCBtZXRob2QsIHBhcmFtcyksIHtcbiAgICAgICAgc2V0KCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVyd3JpdGluZyBhbnkgYXR0cmlidXRlcyBpcyBub3QgYWxsb3dlZCcpXG4gICAgICAgIH1cbiAgICB9KVxufVxuXG4vKipcbiAqIFNldCBwaXBlIFxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcbiAqIEBwYXJhbSAgey4uLmFueX0gZnVuTGlzdCBcbiAqL1xuZnVuY3Rpb24gc2V0UGlwZXMobmFtZSwgLi4uZnVuTGlzdCkge1xuICAgIGZ1bkxpc3QuZm9yRWFjaChmbj0+e1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9KVxuICAgIFNlcGFyYXRlLmdsb2JhbFtuYW1lXSA9IFsuLi5mdW5MaXN0XVxufVxuXG4vKipcbiAqIFNldCBJbnRlcmNlcHRvclxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1biBcbiAqL1xuZnVuY3Rpb24gc2V0SW50ZXJjZXB0b3IobmFtZSwgZnVuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBTZXBhcmF0ZS5nbG9iYWxbbmFtZV0gPSBmdW5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgUHJveHkoY3JlYXRlSW5zdGFuY2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgIC8vIFJlcGxhY2VkIGJ5IGJyb3dzZXJpZnktdmVyc2lvbmlmeSB0cmFuc2Zvcm1cbiAgICAgICAgY2FzZSAndmVyc2lvbic6XG4gICAgICAgICAgICByZXR1cm4gJ19fVkVSU0lPTl9fJ1xuICAgICAgICAvLyBTZXQgcmVxdWVzdCBhbmQgcmVzcG9uc2UgcGlwZVxuICAgICAgICBjYXNlICdyZXFQaXBlcyc6XG4gICAgICAgIGNhc2UgJ3Jlc1BpcGVzJzpcbiAgICAgICAgICAgIHJldHVybiBzZXRQaXBlcy5iaW5kKG51bGwsIHByb3BlcnR5KVxuICAgICAgICAvLyBTZXQgcmVxdWVzdCBhbmQgcmVzcG9uc2UgaW50ZXJjZXB0b3JcbiAgICAgICAgY2FzZSAnYmVmb3JlUmVxJzpcbiAgICAgICAgY2FzZSAnYWZ0ZXJSZXEnOlxuICAgICAgICBjYXNlICdiZWZvcmVSZXMnOlxuICAgICAgICBjYXNlICdhZnRlclJlcyc6XG4gICAgICAgICAgICByZXR1cm4gc2V0SW50ZXJjZXB0b3IuYmluZChudWxsLCBwcm9wZXJ0eSlcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgY2FzZSAnZ2xvYmFsSGVhZGVyJzpcbiAgICAgICAgY2FzZSAnZ2xvYmFsUGFyYW1zJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgU2VwYXJhdGUuZ2xvYmFsW3Byb3BlcnR5XSA9IHZhbHVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pXG5cbiIsImV4cG9ydCBjb25zdCBNRVRIT0RfVFlQRVMgPSBbXG4gICAgJ2dldCcsXG4gICAgJ3Bvc3QnLFxuICAgICdmb3JtJyxcbiAgICAncHVzaCdcbl1cblxuZXhwb3J0IGNvbnN0IENPTlRFTlRfVFlQRSA9IHtcbiAgICBKU09OOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JyxcbiAgICBGT1JNOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04J1xufSIsIi8qKlxuICogRGF0YSBwcm9jZXNzaW5nXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YUZpbHRlcmluZyhwaXBlcywgZGF0YSkge1xuICAgIGNvbnN0IG5ld0RhdGEgPSBbZGF0YSwgLi4ucGlwZXNdLnJlZHVjZSgocHJldiwgY3VyKT0+Y3VyKHByZXYpKVxuICAgIHJldHVybiBuZXdEYXRhXG59Il19"}