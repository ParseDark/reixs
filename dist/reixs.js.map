{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js","node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","node_modules/@babel/runtime/helpers/assertThisInitialized.js","node_modules/@babel/runtime/helpers/asyncToGenerator.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/construct.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/interopRequireWildcard.js","node_modules/@babel/runtime/helpers/iterableToArray.js","node_modules/@babel/runtime/helpers/nonIterableSpread.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/setPrototypeOf.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/typeof.js","node_modules/@babel/runtime/regenerator/index.js","node_modules/regenerator-runtime/runtime.js","src/core/constructor/index.js","src/core/constructor/reixs-all.js","src/core/constructor/reixs.js","src/core/constructor/scheduler.js","src/core/create-request/index.js","src/core/create-request/mark-map.js","src/core/create-request/request-timer.js","src/core/create-request/wait.js","src/core/request/handle-fetch.js","src/core/request/index.js","src/reixs.js","src/shared/constants.js","src/shared/utils.js"],"names":[],"mappings":"AAAA;;;ACAA,MAAM,CAAC,OAAP,GAAiB,OAAO,CAAC,aAAD,CAAP,WAAjB;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","file":"reixs.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports = require('./src/reixs').default","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","function _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nmodule.exports = _interopRequireWildcard;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import reixs from './reixs'\nimport reixsAll from './reixs-all'\n\nexport const Reixs = reixs\nexport const ReixsAll = reixsAll","\nimport createRequest from '../create-request'\n\nimport Scheduler from './scheduler'\n\n/**\n *  Separate request object\n */\nclass AllHandler  extends Scheduler {\n    _schedulers = []\n\n    constructor(...schedulers) {\n        super()\n        this._schedulers = schedulers\n        this._initRequest()\n    }\n\n    /**\n     * Create request function\n     */\n    _initRequest() {\n        const {_config, _sendRequest, _execute, _hook} = this\n        this.request = createRequest(\n            _config, \n            _sendRequest.bind(this), \n            _execute.bind(this), \n            _hook\n        )\n    }\n\n    /**\n     * Concurrent all scheduler\n     * \n     */\n    async _sendRequest() {\n        const {_schedulers} = this\n        const data = await Promise.all(_schedulers.map(scheduler=>{\n            return new Promise( resolve => {\n                scheduler.request.call({\n                    ...scheduler, \n                    injection(data) {\n                        resolve(data)\n                    }\n                })\n            })\n        }))\n        return data\n    }\n}\n\nexport default AllHandler","import {dataFiltering} from '../../shared/utils'\nimport {METHOD_TYPES} from '../../shared/constants'\n\nimport createRequest from '../create-request'\nimport * as request from '../request'\n\nimport Scheduler from './scheduler'\n\n/**\n *  Separate request object\n */\nclass Reixs  extends Scheduler {\n    constructor(url, method = 'get', params = null) {\n        super()\n\n        // Initialize the http\n        this._http = {\n            ...this._http,\n            url,\n            params\n        }\n        this.setMethod(method)\n\n        // Create request function\n        this._initRequest()\n    }\n\n    // Multiple requests Shared\n    static global = {\n        globalHeader: {},\n        globalParams: {},\n        reqPipes: [],\n        resPipes: [],\n        beforeReq: null,\n        afterReq: null,\n        beforeRes: null,\n        afterRes: null\n    }\n\n    // Network request information\n    _http = {\n        url: '',\n        method: null,\n        header: {},\n        params: null,\n        cookie: true\n    }\n    \n    /**\n     * Complete request header\n     * \n     * @return {Object} \n     */\n    get requesetHeader() {\n        const {header} = this._http\n        const {globalHeader} = this.constructor.global\n        return {\n            ...globalHeader, \n            ...header\n        }\n    }\n    \n    /**\n     * Complete request parameters\n     * \n     * @param {Object} params \n     */\n    _getParams(params) {\n        const {globalParams} = this.constructor.global\n        return {\n            ...globalParams, \n            ...params\n        }\n    }\n\n    /**\n     * Create request function\n     */\n    _initRequest() {\n        const {_config, _sendRequest, _execute, _hook} = this\n        this.request = createRequest(\n            _config, \n            _sendRequest.bind(this), \n            _execute.bind(this), \n            _hook\n        )\n    }\n\n    /**\n     * Set the request url\n     * \n     * @param {string} url \n     */\n    setUrl(url) {\n        if (typeof url === 'string') {\n            this._http.url = url\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set the request header\n     * \n     * @param {Object} header \n     */\n    setHeader(header) {\n        if (header.constructor === Object) {\n            this._http.header = header\n        } else {\n            throw new Error('Header invalid setting')\n        }\n        return this\n    }\n\n    /**\n     * Set request parameters\n     * \n     * @param {*} params \n     */\n    setParams(params) {\n        this._http.params = params\n        return this\n    }\n    \n    /**\n     * Set whether to carry cookies\n     * \n     * @param {boolean} ifCookie \n     */\n    setCookie(ifCookie) {\n        if (typeof ifCookie === 'boolean') {\n            this._http.cookie = ifCookie\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Set the request method\n     * \n     * @param {string} method \n     */\n    setMethod(method = null) {\n        method = method.toLowerCase()\n        if (METHOD_TYPES.includes(method)) {\n            this._http.method = method\n        } else {\n            throw new Error('Invalid method')\n        }\n        return this\n    }\n    \n    /**\n     * Send the request to the server\n     * \n     * @param {*} params \n     * @param {string} type \n     */\n    async _sendRequest(params = this._http.params, type) {\n        const {url, method, cookie} = this._http\n        const {errorHook} = this._hook\n        const {reqPipes, resPipes} = this._pipes\n        const {beforeReq, afterReq, beforeRes, afterRes} = this._interceptors\n        const {\n            reqPipes: globalReqPipes, \n            resPipes: globalResPipes,\n            beforeReq: globalBeforeReq,\n            afterReq: globalAfterReq,\n            beforeRes: globalBeforeRes,\n            afterRes: globalAfterRes\n        } = this.constructor.global\n        \n        const requestType = type ? type : method\n        const requestParams = requestType === 'push' \n            ? params : this._getParams(params)\n\n        if ((globalBeforeReq && globalBeforeReq(requestParams) === false) \n        || (beforeReq && beforeReq(requestParams) === false)) {\n            return \n        }\n\n        let finalParams\n        try {\n            finalParams = dataFiltering([...globalReqPipes, ...reqPipes], requestParams)\n        } catch (error) {\n            errorHook(error)\n        }\n        \n        if ((globalAfterReq && globalAfterReq(finalParams) === false) \n        || (afterReq && afterReq(finalParams) === false)) {\n            return \n        }\n\n        const data = await request[requestType](\n            url, \n            finalParams,\n            this.requesetHeader,\n            cookie\n        )\n        \n        \n        if ((globalBeforeRes && globalBeforeRes(data) === false) \n        || (beforeRes && beforeRes(data) === false)) {\n            return \n        }\n\n        let finalData\n        try {\n            finalData = dataFiltering([...globalResPipes, ...resPipes], data)\n        } catch (error) {\n            errorHook(error)\n        }\n\n        if ((globalAfterRes && globalAfterRes(finalData) === false) \n        || (afterRes && afterRes(finalData) === false)) {\n            return \n        }\n\n        return finalData\n    }\n}\n\n\n// Bind request category \nMETHOD_TYPES.map(requestType=>{\n    Reixs.prototype[requestType] = function(params) {\n        this.request(params, requestType)\n    }\n})\n \n\nexport default Reixs","\n// Scheduler is blocked from inheriting an Object\nfunction noProto() {}\nObject.setPrototypeOf(noProto.prototype, Object.create(null))\n\n/**\n * The underlying request model\n */\nexport default class extends noProto {\n    // Request trigger rule configuration\n    _config = {\n        throttle: false,\n        debounce: 0,\n        audit: false,\n        overtime: null\n    }\n\n    // Life cycle function\n    _hook = {\n        prepareHook: null,\n        tartHook: null,\n        endHook: null,\n        errorHook: null\n    }\n\n    // Data filtering\n    _pipes = {\n        reqPipes: [],\n        resPipes: []\n    }\n\n    // Different stage interceptors\n    _interceptors = {\n        beforeReq: null, \n        afterReq: null, \n        beforeRes: null, \n        afterRes: null\n    }\n\n    // Task queue executed after the request is completed\n    _taskList =[]\n\n    /**\n     * Circular call task\n     * @param {*} data \n     */\n    _execute(data) {\n        const {errorHook} = this._hook\n        if (data !== undefined) {\n            try {\n                this._taskList.forEach(task =>{\n                    task(data)\n                })\n            } catch (error) {\n                errorHook && errorHook(error)\n            }\n        }\n    }\n    \n    /**\n     * Set the request filter pipeline\n     * \n     * @param  {...any} pipes \n     */\n    reqPipes(...pipes) {\n        if (pipes.find(pipe =>typeof pipe !== 'function')) {\n            throw new Error('Pipe must be a function')\n        } else {\n            this._pipes.reqPipes = [...pipes]\n        }\n        return this\n    }\n\n    /**\n     * Set the response filter pipeline\n     * \n     * @param  {...any} pipes \n     */\n    resPipes(...pipes) {\n        if (pipes.find(pipe =>typeof pipe !== 'function')) {\n            throw new Error('Pipe must be a function')\n        } else {\n            this._pipes.resPipes = [...pipes]\n        }\n        return this\n    }\n\n    /**\n     * Set throttle\n     * \n     * @param {number|boolean} settings \n     */\n    throttle(settings) {\n        if (typeof settings === 'number' || settings === false) {\n            this._config.throttle = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Set debounce\n     * \n     * @param {number|boolean} settings \n     */\n    debounce(settings) {\n        if (typeof settings === 'number' || settings === false) {\n            this._config.debounce = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set audit\n     * \n     * @param {number|boolean} settings \n     */\n    audit(settings) {\n        if (typeof settings === 'number' || typeof settings === 'boolean') {\n            this._config.audit = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set overtime\n     * \n     * @param {number|null} time \n     */\n    overtime(time) {\n        if (typeof time === 'number' || time === null) {\n            this._config.overtime = time\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set request interceptor\n     * @param {Function} interceptor \n     */\n    reqInterceptor(interceptor) {\n        if (typeof interceptor === 'function') {\n            if (this._pipes.reqPipes.length) {\n                this._interceptors.afterReq = interceptor\n            } else {\n                this._interceptors.beforeReq = interceptor\n            }\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Set response interceptor\n     * @param {Function} interceptor \n     */\n    resInterceptor(interceptor) {\n        if (typeof interceptor === 'function') {\n            if (this._pipes.resPipes.length) {\n                this._interceptors.afterRes = interceptor\n            } else {\n                this._interceptors.beforeRes = interceptor\n            }\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n\n    /**\n     * Add task\n     * \n     * @param {Function} task \n     */\n    task(task) {\n        if (typeof task === 'function') {\n            this._taskList.push(task)\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n\n    /**\n     * Request to prepare\n     * \n     * @param {Function} prepareHook \n     */\n    prepare(prepareHook) {\n        if (typeof prepareHook === 'function') {\n            this._hook.prepareHook = prepareHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n\n    /**\n     * Request to start\n     * \n     * @param {Function} startHook \n     */\n    start(startHook) {\n        if (typeof startHook === 'function') {\n            this._hook.startHook = startHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Request to end\n     * \n     * @param {Function} endHook \n     */\n    end(endHook) {\n        if (typeof endHook === 'function') {\n            this._hook.endHook = endHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Request to error\n     * \n     * @param {Function} errorHook \n     */\n    error(errorHook) {\n        if (typeof errorHook === 'function') {\n            this._hook.errorHook = errorHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n}\n\n","import MarkMap from './mark-map'\nimport {ThrottleWait, DebounceWait} from './wait'\nimport requestTimer from './request-timer'\n\n/**\n * The method to create the request\n * \n * @param {Object} config \n * @param {Function} sendRequest \n * @param {Array} execute \n * @param {Object} hook \n */ \nexport default function(config, sendRequest, execute, hook) {\n    const markMap = new MarkMap()\n    const throttleWait = new ThrottleWait()\n    const debounceWait = new DebounceWait()\n    return async function(...par) {\n        const {prepareHook, startHook, endHook} = hook\n        const {throttle, debounce, audit, overtime} = config\n\n        // External rewrite method\n        const {injection} = this\n\n        prepareHook && prepareHook()\n        let mark\n        if (audit) {\n            mark = markMap.get(audit)\n        }\n        await Promise.all([\n            throttleWait.get(throttle), \n            debounceWait.get(debounce)\n        ])\n        startHook && startHook()\n        const {timeout, data} = await requestTimer(sendRequest(...par), overtime)\n\n        if (data === undefined) {\n            endHook && endHook()\n            return \n        }\n\n        // If audit is set, the duplicate request is discarded\n        if (!audit || markMap.test(mark)) {\n            // If the timeout occurs, the task is not processed\n            if (!timeout) {\n                if (injection) {\n                    injection(data)\n                } else {\n                    execute(data)\n                }\n            }\n            endHook && endHook()\n        }\n    }\n}","/**\n * Verify that mark is deprecated\n */\nexport default class {\n    _map = []\n\n    /**\n     * Get mark\n     * @param {number|boolean} audit \n     */\n    get(audit) {\n        const {_map} = this\n        if (audit) {\n            const sym = Symbol()\n            const time = Date.now()\n            let sign\n            if (!_map.length \n                || (time - _map[_map.length - 1].time > audit \n                    && audit !== true)\n            ) {\n                sign = {\n                    sym, \n                    time\n                }\n                _map.push(sign)\n            } else {\n                sign = _map[_map.length - 1]\n                sign.sym = sym\n                sign.time = time\n            }\n\n            return {\n                sign,\n                sym: sign.sym\n            }\n        }\n        return null\n    }\n\n    /**\n     * Verify the mark\n     * @param {Object} mark \n     */\n    test(mark) {\n        if (mark && mark.sym !== mark.sign.sym) {\n            return false\n        } \n\n        if (mark) {\n            const {_map} = this\n            const index = _map.indexOf(mark.sign)\n            _map.splice(index, 1)\n        }\n        return true\n    }\n}","/**\n * Create delay promise\n * \n * @param {number} time \n */\nfunction createWait(time) {\n    return time === 0 ? Promise.resolve()\n        : new Promise(resolve=>{\n            setTimeout(()=>resolve(), time)\n        })\n}\n\n/**\n * Detect timeout\n * \n * @param {Promise} promise \n * @param {null|number} time \n */\nexport default function requestTimer(promise, time) {\n    const request = promise.then(data=>({\n        timeout: false, \n        data\n    }))\n    const timer = createWait(time).then(()=>({\n        timeout: true, \n        data: null\n    }))\n    return time === null ? request\n        : Promise.race([request, timer])\n}","/**\n * Create wait object\n */\nclass Wait {\n    _timer = null\n\n    /**\n     * Create internal promise\n     * @param {number} time \n     */\n    _createPromise(time) {\n        return time ? new Promise(resolve=>{\n            this._timer =  setTimeout(()=>{ \n                this._timer = null\n                resolve() \n            }, time)\n        }) : Promise.resolve()\n    }\n}\n\n/**\n * Create debounce wait object\n */\nexport class ThrottleWait extends Wait {\n    constructor() {\n        super()\n    }\n\n    /**\n     * get await promise\n     * @param {number} time \n     */\n    get(time) {\n        if (this._timer) {\n            return new Promise(()=>{})\n        }\n        return this._createPromise(time)\n    }\n}\n\n/**\n * Create debounce wait object\n */\nexport class DebounceWait extends Wait {\n    constructor() {\n        super()\n    }\n\n    /**\n     * get await promise\n     * @param {number} time \n     */\n    get(time) {\n        if (this._timer) {\n            clearTimeout(this._timer)\n            this._timer = null\n        }\n        return this._createPromise(time)\n    }\n}","\n/**\n * Check for success\n * \n * @param {Object} response \n */\nfunction checkStatus(response) {\n    if (response.status >= 200 && response.status < 300) {\n        const contentType = response.headers.get('content-type')\n        if (contentType && contentType.includes('application/json')) {\n            return response.json()\n        } else {\n            return response.text()\n        }\n    } else {\n        throw new Error()\n    }\n}\n\n/**\n * Handle fetch\n * \n * @param {Object} promise \n */\nexport default function handleFetch(promise) {\n    return promise\n        .then(response => checkStatus(response))\n        .catch(error => {\n            throw error\n        })\n}","import {CONTENT_TYPE} from '../../shared/constants'\nimport handleFetch from './handle-fetch'\n\n\n/**\n * Query String Parameters\n *\n * @param {string} url\n * @param {*} params\n * @param {Object} headers\n * @param {boolean} cookie\n */\nexport function get(url, params, headers, cookie) {\n    url = new URL(url)\n    Object.keys(params)\n        .forEach(key => url.searchParams.append(key, params[key]))\n    const promise = fetch(url, {\n        method: 'GET',\n        headers: {\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Dynamic Router\n *\n * @param {string} url\n * @param {*} params\n * @param {Object} headers\n * @param {boolean} cookie\n */\nexport function push(url, params, headers, cookie) {\n    url = new URL(url)\n    url.pathname += `/${params}`\n    const promise = fetch(url, {\n        method: 'GET',\n        headers: {\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Request Payload\n *\n * @param {string} url\n * @param {*} data\n * @param {Object} headers\n * @param {boolean} cookie\n */\nexport function post(url, data, headers, cookie) {\n    url = new URL(url)\n    const promise = fetch(url, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: {\n            'Content-type': CONTENT_TYPE['JSON'],\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Form Data\n *\n * @param {string} url\n * @param {*} formData\n * @param {Object} headers\n * @param {boolean} cookie\n */\nexport function form(url, formData, headers, cookie) {\n    url = new URL(url)\n    const promise = fetch(url, {\n        method: 'POST',\n        body: formData,\n        headers: {\n            'Content-type': CONTENT_TYPE['FORM'],\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n","import {Reixs, ReixsAll} from './core/constructor'\n\n/**\n * Set pipe \n * \n * @param {string} name \n * @param  {...any} funList \n */\nfunction setPipes(name, ...funList) {\n    funList.forEach(fn=>{\n        if (typeof fn !== 'function') {\n            throw new Error('Invalid type')\n        }\n    })\n    Reixs.global[name] = [...funList]\n}\n\n/**\n * Set Interceptor\n * \n * @param {string} name \n * @param {Function} fun \n */\nfunction setInterceptor(name, fun) {\n    if (typeof fn === 'function') {\n        Reixs.global[name] = fun\n    } else {\n        throw new Error('Invalid type')\n    }\n}\n\n/**\n * \n * @param {string} url \n * @param {string} method \n * @param {*} params \n */\nfunction reixs(url, method, params) {\n    return  new Reixs(url, method, params)\n}\n\n// reixs.all\nreixs.all = (...scheduler) => new ReixsAll(...scheduler)\n\n\n// Replaced by browserify-versionify transform\nreixs.version = '__VERSION__'\n\n// Set request and response pipe\nreixs.reqPipes = setPipes.bind(null, 'reqPipes')\nreixs.resPipes = setPipes.bind(null, 'resPipes')\n\n// Set request and response interceptor\nreixs.beforeReq = setInterceptor.bind(null, 'beforeReq')\nreixs.afterReq = setInterceptor.bind(null, 'afterReq')\nreixs.beforeRes = setInterceptor.bind(null, 'beforeRes')\nreixs.afterRes = setInterceptor.bind(null, 'afterRes')\n\n// Set global header\nReflect.defineProperty(reixs, 'globalHeader', {\n    set(value) {\n        Reixs.global.globalHeader = value\n    }\n})\n\n// Set global params\nReflect.defineProperty(reixs, 'globalParams', {\n    set(value) {\n        Reixs.global.globalParams = value\n    }\n})\n\nexport default reixs\n\n\n","export const METHOD_TYPES = [\n    'get',\n    'post',\n    'form',\n    'push'\n]\n\nexport const CONTENT_TYPE = {\n    JSON: 'application/json;charset=UTF-8',\n    FORM: 'application/x-www-form-urlencoded; charset=UTF-8'\n}","/**\n * Data processing\n *\n * @param {*} data \n */\nexport function dataFiltering(pipes, data) {\n    const newData = [data, ...pipes].reduce((prev, cur)=>cur(prev))\n    return newData\n}"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY29uc3RydWN0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwic3JjL2NvcmUvY29uc3RydWN0b3IvaW5kZXguanMiLCJzcmMvY29yZS9jb25zdHJ1Y3Rvci9yZWl4cy1hbGwuanMiLCJzcmMvY29yZS9jb25zdHJ1Y3Rvci9yZWl4cy5qcyIsInNyYy9jb3JlL2NvbnN0cnVjdG9yL3NjaGVkdWxlci5qcyIsInNyYy9jb3JlL2NyZWF0ZS1yZXF1ZXN0L2luZGV4LmpzIiwic3JjL2NvcmUvY3JlYXRlLXJlcXVlc3QvbWFyay1tYXAuanMiLCJzcmMvY29yZS9jcmVhdGUtcmVxdWVzdC9yZXF1ZXN0LXRpbWVyLmpzIiwic3JjL2NvcmUvY3JlYXRlLXJlcXVlc3Qvd2FpdC5qcyIsInNyYy9jb3JlL3JlcXVlc3QvaGFuZGxlLWZldGNoLmpzIiwic3JjL2NvcmUvcmVxdWVzdC9pbmRleC5qcyIsInNyYy9yZWl4cy5qcyIsInNyYy9zaGFyZWQvY29uc3RhbnRzLmpzIiwic3JjL3NoYXJlZC91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsT0FBTyxDQUFDLGFBQUQsQ0FBUCxXQUFqQjs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QyxNQUFNLE9BQU8sR0FBRyxDQUFDLElBQUQsNkNBQVUsS0FBVixHQUFpQixNQUFqQixDQUF3QixVQUFDLElBQUQsRUFBTyxHQUFQO0FBQUEsV0FBYSxHQUFHLENBQUMsSUFBRCxDQUFoQjtBQUFBLEdBQXhCLENBQWhCO0FBQ0EsU0FBTyxPQUFQO0FBQ0giLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3JjL3JlaXhzJykuZGVmYXVsdCIsImZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIHNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5ld09iaiA9IHt9O1xuXG4gICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307XG5cbiAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcbiAgICByZXR1cm4gbmV3T2JqO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyIsImZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZjIgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mMihvYmopOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZjIoU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsImltcG9ydCByZWl4cyBmcm9tICcuL3JlaXhzJ1xuaW1wb3J0IHJlaXhzQWxsIGZyb20gJy4vcmVpeHMtYWxsJ1xuXG5leHBvcnQgY29uc3QgUmVpeHMgPSByZWl4c1xuZXhwb3J0IGNvbnN0IFJlaXhzQWxsID0gcmVpeHNBbGwiLCJcbmltcG9ydCBjcmVhdGVSZXF1ZXN0IGZyb20gJy4uL2NyZWF0ZS1yZXF1ZXN0J1xuXG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJy4vc2NoZWR1bGVyJ1xuXG4vKipcbiAqICBTZXBhcmF0ZSByZXF1ZXN0IG9iamVjdFxuICovXG5jbGFzcyBBbGxIYW5kbGVyICBleHRlbmRzIFNjaGVkdWxlciB7XG4gICAgX3NjaGVkdWxlcnMgPSBbXVxuXG4gICAgY29uc3RydWN0b3IoLi4uc2NoZWR1bGVycykge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlcnMgPSBzY2hlZHVsZXJzXG4gICAgICAgIHRoaXMuX2luaXRSZXF1ZXN0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcmVxdWVzdCBmdW5jdGlvblxuICAgICAqL1xuICAgIF9pbml0UmVxdWVzdCgpIHtcbiAgICAgICAgY29uc3Qge19jb25maWcsIF9zZW5kUmVxdWVzdCwgX2V4ZWN1dGUsIF9ob29rfSA9IHRoaXNcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChcbiAgICAgICAgICAgIF9jb25maWcsIFxuICAgICAgICAgICAgX3NlbmRSZXF1ZXN0LmJpbmQodGhpcyksIFxuICAgICAgICAgICAgX2V4ZWN1dGUuYmluZCh0aGlzKSwgXG4gICAgICAgICAgICBfaG9va1xuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uY3VycmVudCBhbGwgc2NoZWR1bGVyXG4gICAgICogXG4gICAgICovXG4gICAgYXN5bmMgX3NlbmRSZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCB7X3NjaGVkdWxlcnN9ID0gdGhpc1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwoX3NjaGVkdWxlcnMubWFwKHNjaGVkdWxlcj0+e1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCByZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXIucmVxdWVzdC5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc2NoZWR1bGVyLCBcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSlcbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFsbEhhbmRsZXIiLCJpbXBvcnQge2RhdGFGaWx0ZXJpbmd9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscydcbmltcG9ydCB7TUVUSE9EX1RZUEVTfSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzJ1xuXG5pbXBvcnQgY3JlYXRlUmVxdWVzdCBmcm9tICcuLi9jcmVhdGUtcmVxdWVzdCdcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnLi4vcmVxdWVzdCdcblxuaW1wb3J0IFNjaGVkdWxlciBmcm9tICcuL3NjaGVkdWxlcidcblxuLyoqXG4gKiAgU2VwYXJhdGUgcmVxdWVzdCBvYmplY3RcbiAqL1xuY2xhc3MgUmVpeHMgIGV4dGVuZHMgU2NoZWR1bGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG1ldGhvZCA9ICdnZXQnLCBwYXJhbXMgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKClcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBodHRwXG4gICAgICAgIHRoaXMuX2h0dHAgPSB7XG4gICAgICAgICAgICAuLi50aGlzLl9odHRwLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRNZXRob2QobWV0aG9kKVxuXG4gICAgICAgIC8vIENyZWF0ZSByZXF1ZXN0IGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX2luaXRSZXF1ZXN0KClcbiAgICB9XG5cbiAgICAvLyBNdWx0aXBsZSByZXF1ZXN0cyBTaGFyZWRcbiAgICBzdGF0aWMgZ2xvYmFsID0ge1xuICAgICAgICBnbG9iYWxIZWFkZXI6IHt9LFxuICAgICAgICBnbG9iYWxQYXJhbXM6IHt9LFxuICAgICAgICByZXFQaXBlczogW10sXG4gICAgICAgIHJlc1BpcGVzOiBbXSxcbiAgICAgICAgYmVmb3JlUmVxOiBudWxsLFxuICAgICAgICBhZnRlclJlcTogbnVsbCxcbiAgICAgICAgYmVmb3JlUmVzOiBudWxsLFxuICAgICAgICBhZnRlclJlczogbnVsbFxuICAgIH1cblxuICAgIC8vIE5ldHdvcmsgcmVxdWVzdCBpbmZvcm1hdGlvblxuICAgIF9odHRwID0ge1xuICAgICAgICB1cmw6ICcnLFxuICAgICAgICBtZXRob2Q6IG51bGwsXG4gICAgICAgIGhlYWRlcjoge30sXG4gICAgICAgIHBhcmFtczogbnVsbCxcbiAgICAgICAgY29va2llOiB0cnVlXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIHJlcXVlc3QgaGVhZGVyXG4gICAgICogXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBcbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzZXRIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IHtoZWFkZXJ9ID0gdGhpcy5faHR0cFxuICAgICAgICBjb25zdCB7Z2xvYmFsSGVhZGVyfSA9IHRoaXMuY29uc3RydWN0b3IuZ2xvYmFsXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nbG9iYWxIZWFkZXIsIFxuICAgICAgICAgICAgLi4uaGVhZGVyXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQ29tcGxldGUgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBcbiAgICAgKi9cbiAgICBfZ2V0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7Z2xvYmFsUGFyYW1zfSA9IHRoaXMuY29uc3RydWN0b3IuZ2xvYmFsXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nbG9iYWxQYXJhbXMsIFxuICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcmVxdWVzdCBmdW5jdGlvblxuICAgICAqL1xuICAgIF9pbml0UmVxdWVzdCgpIHtcbiAgICAgICAgY29uc3Qge19jb25maWcsIF9zZW5kUmVxdWVzdCwgX2V4ZWN1dGUsIF9ob29rfSA9IHRoaXNcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChcbiAgICAgICAgICAgIF9jb25maWcsIFxuICAgICAgICAgICAgX3NlbmRSZXF1ZXN0LmJpbmQodGhpcyksIFxuICAgICAgICAgICAgX2V4ZWN1dGUuYmluZCh0aGlzKSwgXG4gICAgICAgICAgICBfaG9va1xuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IHVybFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgXG4gICAgICovXG4gICAgc2V0VXJsKHVybCkge1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAudXJsID0gdXJsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IGhlYWRlclxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXIgXG4gICAgICovXG4gICAgc2V0SGVhZGVyKGhlYWRlcikge1xuICAgICAgICBpZiAoaGVhZGVyLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAuaGVhZGVyID0gaGVhZGVyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYWRlciBpbnZhbGlkIHNldHRpbmcnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHJlcXVlc3QgcGFyYW1ldGVyc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gcGFyYW1zIFxuICAgICAqL1xuICAgIHNldFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5faHR0cC5wYXJhbXMgPSBwYXJhbXNcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdG8gY2FycnkgY29va2llc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWZDb29raWUgXG4gICAgICovXG4gICAgc2V0Q29va2llKGlmQ29va2llKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWZDb29raWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5faHR0cC5jb29raWUgPSBpZkNvb2tpZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IG1ldGhvZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgXG4gICAgICovXG4gICAgc2V0TWV0aG9kKG1ldGhvZCA9IG51bGwpIHtcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKClcbiAgICAgICAgaWYgKE1FVEhPRF9UWVBFUy5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzLl9odHRwLm1ldGhvZCA9IG1ldGhvZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCcpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgcmVxdWVzdCB0byB0aGUgc2VydmVyXG4gICAgICogXG4gICAgICogQHBhcmFtIHsqfSBwYXJhbXMgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXG4gICAgICovXG4gICAgYXN5bmMgX3NlbmRSZXF1ZXN0KHBhcmFtcyA9IHRoaXMuX2h0dHAucGFyYW1zLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHt1cmwsIG1ldGhvZCwgY29va2llfSA9IHRoaXMuX2h0dHBcbiAgICAgICAgY29uc3Qge2Vycm9ySG9va30gPSB0aGlzLl9ob29rXG4gICAgICAgIGNvbnN0IHtyZXFQaXBlcywgcmVzUGlwZXN9ID0gdGhpcy5fcGlwZXNcbiAgICAgICAgY29uc3Qge2JlZm9yZVJlcSwgYWZ0ZXJSZXEsIGJlZm9yZVJlcywgYWZ0ZXJSZXN9ID0gdGhpcy5faW50ZXJjZXB0b3JzXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHJlcVBpcGVzOiBnbG9iYWxSZXFQaXBlcywgXG4gICAgICAgICAgICByZXNQaXBlczogZ2xvYmFsUmVzUGlwZXMsXG4gICAgICAgICAgICBiZWZvcmVSZXE6IGdsb2JhbEJlZm9yZVJlcSxcbiAgICAgICAgICAgIGFmdGVyUmVxOiBnbG9iYWxBZnRlclJlcSxcbiAgICAgICAgICAgIGJlZm9yZVJlczogZ2xvYmFsQmVmb3JlUmVzLFxuICAgICAgICAgICAgYWZ0ZXJSZXM6IGdsb2JhbEFmdGVyUmVzXG4gICAgICAgIH0gPSB0aGlzLmNvbnN0cnVjdG9yLmdsb2JhbFxuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVxdWVzdFR5cGUgPSB0eXBlID8gdHlwZSA6IG1ldGhvZFxuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gcmVxdWVzdFR5cGUgPT09ICdwdXNoJyBcbiAgICAgICAgICAgID8gcGFyYW1zIDogdGhpcy5fZ2V0UGFyYW1zKHBhcmFtcylcblxuICAgICAgICBpZiAoKGdsb2JhbEJlZm9yZVJlcSAmJiBnbG9iYWxCZWZvcmVSZXEocmVxdWVzdFBhcmFtcykgPT09IGZhbHNlKSBcbiAgICAgICAgfHwgKGJlZm9yZVJlcSAmJiBiZWZvcmVSZXEocmVxdWVzdFBhcmFtcykgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZpbmFsUGFyYW1zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5hbFBhcmFtcyA9IGRhdGFGaWx0ZXJpbmcoWy4uLmdsb2JhbFJlcVBpcGVzLCAuLi5yZXFQaXBlc10sIHJlcXVlc3RQYXJhbXMpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvckhvb2soZXJyb3IpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICgoZ2xvYmFsQWZ0ZXJSZXEgJiYgZ2xvYmFsQWZ0ZXJSZXEoZmluYWxQYXJhbXMpID09PSBmYWxzZSkgXG4gICAgICAgIHx8IChhZnRlclJlcSAmJiBhZnRlclJlcShmaW5hbFBhcmFtcykgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcXVlc3RbcmVxdWVzdFR5cGVdKFxuICAgICAgICAgICAgdXJsLCBcbiAgICAgICAgICAgIGZpbmFsUGFyYW1zLFxuICAgICAgICAgICAgdGhpcy5yZXF1ZXNldEhlYWRlcixcbiAgICAgICAgICAgIGNvb2tpZVxuICAgICAgICApXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYgKChnbG9iYWxCZWZvcmVSZXMgJiYgZ2xvYmFsQmVmb3JlUmVzKGRhdGEpID09PSBmYWxzZSkgXG4gICAgICAgIHx8IChiZWZvcmVSZXMgJiYgYmVmb3JlUmVzKGRhdGEpID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaW5hbERhdGFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmFsRGF0YSA9IGRhdGFGaWx0ZXJpbmcoWy4uLmdsb2JhbFJlc1BpcGVzLCAuLi5yZXNQaXBlc10sIGRhdGEpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvckhvb2soZXJyb3IpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGdsb2JhbEFmdGVyUmVzICYmIGdsb2JhbEFmdGVyUmVzKGZpbmFsRGF0YSkgPT09IGZhbHNlKSBcbiAgICAgICAgfHwgKGFmdGVyUmVzICYmIGFmdGVyUmVzKGZpbmFsRGF0YSkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbmFsRGF0YVxuICAgIH1cbn1cblxuXG4vLyBCaW5kIHJlcXVlc3QgY2F0ZWdvcnkgXG5NRVRIT0RfVFlQRVMubWFwKHJlcXVlc3RUeXBlPT57XG4gICAgUmVpeHMucHJvdG90eXBlW3JlcXVlc3RUeXBlXSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB0aGlzLnJlcXVlc3QocGFyYW1zLCByZXF1ZXN0VHlwZSlcbiAgICB9XG59KVxuIFxuXG5leHBvcnQgZGVmYXVsdCBSZWl4cyIsIlxuLy8gU2NoZWR1bGVyIGlzIGJsb2NrZWQgZnJvbSBpbmhlcml0aW5nIGFuIE9iamVjdFxuZnVuY3Rpb24gbm9Qcm90bygpIHt9XG5PYmplY3Quc2V0UHJvdG90eXBlT2Yobm9Qcm90by5wcm90b3R5cGUsIE9iamVjdC5jcmVhdGUobnVsbCkpXG5cbi8qKlxuICogVGhlIHVuZGVybHlpbmcgcmVxdWVzdCBtb2RlbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIG5vUHJvdG8ge1xuICAgIC8vIFJlcXVlc3QgdHJpZ2dlciBydWxlIGNvbmZpZ3VyYXRpb25cbiAgICBfY29uZmlnID0ge1xuICAgICAgICB0aHJvdHRsZTogZmFsc2UsXG4gICAgICAgIGRlYm91bmNlOiAwLFxuICAgICAgICBhdWRpdDogZmFsc2UsXG4gICAgICAgIG92ZXJ0aW1lOiBudWxsXG4gICAgfVxuXG4gICAgLy8gTGlmZSBjeWNsZSBmdW5jdGlvblxuICAgIF9ob29rID0ge1xuICAgICAgICBwcmVwYXJlSG9vazogbnVsbCxcbiAgICAgICAgdGFydEhvb2s6IG51bGwsXG4gICAgICAgIGVuZEhvb2s6IG51bGwsXG4gICAgICAgIGVycm9ySG9vazogbnVsbFxuICAgIH1cblxuICAgIC8vIERhdGEgZmlsdGVyaW5nXG4gICAgX3BpcGVzID0ge1xuICAgICAgICByZXFQaXBlczogW10sXG4gICAgICAgIHJlc1BpcGVzOiBbXVxuICAgIH1cblxuICAgIC8vIERpZmZlcmVudCBzdGFnZSBpbnRlcmNlcHRvcnNcbiAgICBfaW50ZXJjZXB0b3JzID0ge1xuICAgICAgICBiZWZvcmVSZXE6IG51bGwsIFxuICAgICAgICBhZnRlclJlcTogbnVsbCwgXG4gICAgICAgIGJlZm9yZVJlczogbnVsbCwgXG4gICAgICAgIGFmdGVyUmVzOiBudWxsXG4gICAgfVxuXG4gICAgLy8gVGFzayBxdWV1ZSBleGVjdXRlZCBhZnRlciB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZWRcbiAgICBfdGFza0xpc3QgPVtdXG5cbiAgICAvKipcbiAgICAgKiBDaXJjdWxhciBjYWxsIHRhc2tcbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgXG4gICAgICovXG4gICAgX2V4ZWN1dGUoZGF0YSkge1xuICAgICAgICBjb25zdCB7ZXJyb3JIb29rfSA9IHRoaXMuX2hvb2tcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXNrTGlzdC5mb3JFYWNoKHRhc2sgPT57XG4gICAgICAgICAgICAgICAgICAgIHRhc2soZGF0YSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvckhvb2sgJiYgZXJyb3JIb29rKGVycm9yKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcmVxdWVzdCBmaWx0ZXIgcGlwZWxpbmVcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IHBpcGVzIFxuICAgICAqL1xuICAgIHJlcVBpcGVzKC4uLnBpcGVzKSB7XG4gICAgICAgIGlmIChwaXBlcy5maW5kKHBpcGUgPT50eXBlb2YgcGlwZSAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGlwZSBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGlwZXMucmVxUGlwZXMgPSBbLi4ucGlwZXNdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHJlc3BvbnNlIGZpbHRlciBwaXBlbGluZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gcGlwZXMgXG4gICAgICovXG4gICAgcmVzUGlwZXMoLi4ucGlwZXMpIHtcbiAgICAgICAgaWYgKHBpcGVzLmZpbmQocGlwZSA9PnR5cGVvZiBwaXBlICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXBlIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9waXBlcy5yZXNQaXBlcyA9IFsuLi5waXBlc11cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aHJvdHRsZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IHNldHRpbmdzIFxuICAgICAqL1xuICAgIHRocm90dGxlKHNldHRpbmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdudW1iZXInIHx8IHNldHRpbmdzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLnRocm90dGxlID0gc2V0dGluZ3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBkZWJvdW5jZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IHNldHRpbmdzIFxuICAgICAqL1xuICAgIGRlYm91bmNlKHNldHRpbmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdudW1iZXInIHx8IHNldHRpbmdzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLmRlYm91bmNlID0gc2V0dGluZ3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBTZXQgYXVkaXRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcnxib29sZWFufSBzZXR0aW5ncyBcbiAgICAgKi9cbiAgICBhdWRpdChzZXR0aW5ncykge1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc2V0dGluZ3MgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLmF1ZGl0ID0gc2V0dGluZ3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBTZXQgb3ZlcnRpbWVcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcnxudWxsfSB0aW1lIFxuICAgICAqL1xuICAgIG92ZXJ0aW1lKHRpbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lID09PSAnbnVtYmVyJyB8fCB0aW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcub3ZlcnRpbWUgPSB0aW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IHJlcXVlc3QgaW50ZXJjZXB0b3JcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBcbiAgICAgKi9cbiAgICByZXFJbnRlcmNlcHRvcihpbnRlcmNlcHRvcikge1xuICAgICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGlwZXMucmVxUGlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJjZXB0b3JzLmFmdGVyUmVxID0gaW50ZXJjZXB0b3JcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJjZXB0b3JzLmJlZm9yZVJlcSA9IGludGVyY2VwdG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFNldCByZXNwb25zZSBpbnRlcmNlcHRvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFxuICAgICAqL1xuICAgIHJlc0ludGVyY2VwdG9yKGludGVyY2VwdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9waXBlcy5yZXNQaXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcmNlcHRvcnMuYWZ0ZXJSZXMgPSBpbnRlcmNlcHRvclxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcmNlcHRvcnMuYmVmb3JlUmVzID0gaW50ZXJjZXB0b3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGFza1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2sgXG4gICAgICovXG4gICAgdGFzayh0YXNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fdGFza0xpc3QucHVzaCh0YXNrKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdG8gcHJlcGFyZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXBhcmVIb29rIFxuICAgICAqL1xuICAgIHByZXBhcmUocHJlcGFyZUhvb2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVwYXJlSG9vayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5faG9vay5wcmVwYXJlSG9vayA9IHByZXBhcmVIb29rXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0byBzdGFydFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0YXJ0SG9vayBcbiAgICAgKi9cbiAgICBzdGFydChzdGFydEhvb2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFydEhvb2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvb2suc3RhcnRIb29rID0gc3RhcnRIb29rXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdG8gZW5kXG4gICAgICogXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZW5kSG9vayBcbiAgICAgKi9cbiAgICBlbmQoZW5kSG9vaykge1xuICAgICAgICBpZiAodHlwZW9mIGVuZEhvb2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvb2suZW5kSG9vayA9IGVuZEhvb2tcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0byBlcnJvclxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9ySG9vayBcbiAgICAgKi9cbiAgICBlcnJvcihlcnJvckhvb2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvckhvb2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvb2suZXJyb3JIb29rID0gZXJyb3JIb29rXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgTWFya01hcCBmcm9tICcuL21hcmstbWFwJ1xuaW1wb3J0IHtUaHJvdHRsZVdhaXQsIERlYm91bmNlV2FpdH0gZnJvbSAnLi93YWl0J1xuaW1wb3J0IHJlcXVlc3RUaW1lciBmcm9tICcuL3JlcXVlc3QtdGltZXInXG5cbi8qKlxuICogVGhlIG1ldGhvZCB0byBjcmVhdGUgdGhlIHJlcXVlc3RcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNlbmRSZXF1ZXN0IFxuICogQHBhcmFtIHtBcnJheX0gZXhlY3V0ZSBcbiAqIEBwYXJhbSB7T2JqZWN0fSBob29rIFxuICovIFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29uZmlnLCBzZW5kUmVxdWVzdCwgZXhlY3V0ZSwgaG9vaykge1xuICAgIGNvbnN0IG1hcmtNYXAgPSBuZXcgTWFya01hcCgpXG4gICAgY29uc3QgdGhyb3R0bGVXYWl0ID0gbmV3IFRocm90dGxlV2FpdCgpXG4gICAgY29uc3QgZGVib3VuY2VXYWl0ID0gbmV3IERlYm91bmNlV2FpdCgpXG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKC4uLnBhcikge1xuICAgICAgICBjb25zdCB7cHJlcGFyZUhvb2ssIHN0YXJ0SG9vaywgZW5kSG9va30gPSBob29rXG4gICAgICAgIGNvbnN0IHt0aHJvdHRsZSwgZGVib3VuY2UsIGF1ZGl0LCBvdmVydGltZX0gPSBjb25maWdcblxuICAgICAgICAvLyBFeHRlcm5hbCByZXdyaXRlIG1ldGhvZFxuICAgICAgICBjb25zdCB7aW5qZWN0aW9ufSA9IHRoaXNcblxuICAgICAgICBwcmVwYXJlSG9vayAmJiBwcmVwYXJlSG9vaygpXG4gICAgICAgIGxldCBtYXJrXG4gICAgICAgIGlmIChhdWRpdCkge1xuICAgICAgICAgICAgbWFyayA9IG1hcmtNYXAuZ2V0KGF1ZGl0KVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRocm90dGxlV2FpdC5nZXQodGhyb3R0bGUpLCBcbiAgICAgICAgICAgIGRlYm91bmNlV2FpdC5nZXQoZGVib3VuY2UpXG4gICAgICAgIF0pXG4gICAgICAgIHN0YXJ0SG9vayAmJiBzdGFydEhvb2soKVxuICAgICAgICBjb25zdCB7dGltZW91dCwgZGF0YX0gPSBhd2FpdCByZXF1ZXN0VGltZXIoc2VuZFJlcXVlc3QoLi4ucGFyKSwgb3ZlcnRpbWUpXG5cbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5kSG9vayAmJiBlbmRIb29rKClcbiAgICAgICAgICAgIHJldHVybiBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGF1ZGl0IGlzIHNldCwgdGhlIGR1cGxpY2F0ZSByZXF1ZXN0IGlzIGRpc2NhcmRlZFxuICAgICAgICBpZiAoIWF1ZGl0IHx8IG1hcmtNYXAudGVzdChtYXJrKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRpbWVvdXQgb2NjdXJzLCB0aGUgdGFzayBpcyBub3QgcHJvY2Vzc2VkXG4gICAgICAgICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5qZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdGlvbihkYXRhKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGUoZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRIb29rICYmIGVuZEhvb2soKVxuICAgICAgICB9XG4gICAgfVxufSIsIi8qKlxuICogVmVyaWZ5IHRoYXQgbWFyayBpcyBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgICBfbWFwID0gW11cblxuICAgIC8qKlxuICAgICAqIEdldCBtYXJrXG4gICAgICogQHBhcmFtIHtudW1iZXJ8Ym9vbGVhbn0gYXVkaXQgXG4gICAgICovXG4gICAgZ2V0KGF1ZGl0KSB7XG4gICAgICAgIGNvbnN0IHtfbWFwfSA9IHRoaXNcbiAgICAgICAgaWYgKGF1ZGl0KSB7XG4gICAgICAgICAgICBjb25zdCBzeW0gPSBTeW1ib2woKVxuICAgICAgICAgICAgY29uc3QgdGltZSA9IERhdGUubm93KClcbiAgICAgICAgICAgIGxldCBzaWduXG4gICAgICAgICAgICBpZiAoIV9tYXAubGVuZ3RoIFxuICAgICAgICAgICAgICAgIHx8ICh0aW1lIC0gX21hcFtfbWFwLmxlbmd0aCAtIDFdLnRpbWUgPiBhdWRpdCBcbiAgICAgICAgICAgICAgICAgICAgJiYgYXVkaXQgIT09IHRydWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzaWduID0ge1xuICAgICAgICAgICAgICAgICAgICBzeW0sIFxuICAgICAgICAgICAgICAgICAgICB0aW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9tYXAucHVzaChzaWduKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduID0gX21hcFtfbWFwLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgc2lnbi5zeW0gPSBzeW1cbiAgICAgICAgICAgICAgICBzaWduLnRpbWUgPSB0aW1lXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgICAgICBzeW06IHNpZ24uc3ltXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgdGhlIG1hcmtcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFyayBcbiAgICAgKi9cbiAgICB0ZXN0KG1hcmspIHtcbiAgICAgICAgaWYgKG1hcmsgJiYgbWFyay5zeW0gIT09IG1hcmsuc2lnbi5zeW0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBjb25zdCB7X21hcH0gPSB0aGlzXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IF9tYXAuaW5kZXhPZihtYXJrLnNpZ24pXG4gICAgICAgICAgICBfbWFwLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbn0iLCIvKipcbiAqIENyZWF0ZSBkZWxheSBwcm9taXNlXG4gKiBcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFxuICovXG5mdW5jdGlvbiBjcmVhdGVXYWl0KHRpbWUpIHtcbiAgICByZXR1cm4gdGltZSA9PT0gMCA/IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIDogbmV3IFByb21pc2UocmVzb2x2ZT0+e1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+cmVzb2x2ZSgpLCB0aW1lKVxuICAgICAgICB9KVxufVxuXG4vKipcbiAqIERldGVjdCB0aW1lb3V0XG4gKiBcbiAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBcbiAqIEBwYXJhbSB7bnVsbHxudW1iZXJ9IHRpbWUgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcXVlc3RUaW1lcihwcm9taXNlLCB0aW1lKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHByb21pc2UudGhlbihkYXRhPT4oe1xuICAgICAgICB0aW1lb3V0OiBmYWxzZSwgXG4gICAgICAgIGRhdGFcbiAgICB9KSlcbiAgICBjb25zdCB0aW1lciA9IGNyZWF0ZVdhaXQodGltZSkudGhlbigoKT0+KHtcbiAgICAgICAgdGltZW91dDogdHJ1ZSwgXG4gICAgICAgIGRhdGE6IG51bGxcbiAgICB9KSlcbiAgICByZXR1cm4gdGltZSA9PT0gbnVsbCA/IHJlcXVlc3RcbiAgICAgICAgOiBQcm9taXNlLnJhY2UoW3JlcXVlc3QsIHRpbWVyXSlcbn0iLCIvKipcbiAqIENyZWF0ZSB3YWl0IG9iamVjdFxuICovXG5jbGFzcyBXYWl0IHtcbiAgICBfdGltZXIgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgaW50ZXJuYWwgcHJvbWlzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFxuICAgICAqL1xuICAgIF9jcmVhdGVQcm9taXNlKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUgPyBuZXcgUHJvbWlzZShyZXNvbHZlPT57XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9ICBzZXRUaW1lb3V0KCgpPT57IFxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbFxuICAgICAgICAgICAgICAgIHJlc29sdmUoKSBcbiAgICAgICAgICAgIH0sIHRpbWUpXG4gICAgICAgIH0pIDogUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGRlYm91bmNlIHdhaXQgb2JqZWN0XG4gKi9cbmV4cG9ydCBjbGFzcyBUaHJvdHRsZVdhaXQgZXh0ZW5kcyBXYWl0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhd2FpdCBwcm9taXNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgXG4gICAgICovXG4gICAgZ2V0KHRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQcm9taXNlKHRpbWUpXG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBkZWJvdW5jZSB3YWl0IG9iamVjdFxuICovXG5leHBvcnQgY2xhc3MgRGVib3VuY2VXYWl0IGV4dGVuZHMgV2FpdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYXdhaXQgcHJvbWlzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFxuICAgICAqL1xuICAgIGdldCh0aW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKVxuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVByb21pc2UodGltZSlcbiAgICB9XG59IiwiXG4vKipcbiAqIENoZWNrIGZvciBzdWNjZXNzXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBcbiAqL1xuZnVuY3Rpb24gY2hlY2tTdGF0dXMocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJylcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KClcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpXG4gICAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBmZXRjaFxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvbWlzZSBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGFuZGxlRmV0Y2gocHJvbWlzZSkge1xuICAgIHJldHVybiBwcm9taXNlXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IGNoZWNrU3RhdHVzKHJlc3BvbnNlKSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH0pXG59IiwiaW1wb3J0IHtDT05URU5UX1RZUEV9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMnXG5pbXBvcnQgaGFuZGxlRmV0Y2ggZnJvbSAnLi9oYW5kbGUtZmV0Y2gnXG5cblxuLyoqXG4gKiBRdWVyeSBTdHJpbmcgUGFyYW1ldGVyc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7Kn0gcGFyYW1zXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xuICogQHBhcmFtIHtib29sZWFufSBjb29raWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldCh1cmwsIHBhcmFtcywgaGVhZGVycywgY29va2llKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgT2JqZWN0LmtleXMocGFyYW1zKVxuICAgICAgICAuZm9yRWFjaChrZXkgPT4gdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBwYXJhbXNba2V5XSkpXG4gICAgY29uc3QgcHJvbWlzZSA9IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiBjb29raWUgPyAnaW5jbHVkZScgOiAnb21pdCdcbiAgICB9KVxuICAgIHJldHVybiBoYW5kbGVGZXRjaChwcm9taXNlKVxufVxuXG4vKipcbiAqIER5bmFtaWMgUm91dGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHsqfSBwYXJhbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvb2tpZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaCh1cmwsIHBhcmFtcywgaGVhZGVycywgY29va2llKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgdXJsLnBhdGhuYW1lICs9IGAvJHtwYXJhbXN9YFxuICAgIGNvbnN0IHByb21pc2UgPSBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogY29va2llID8gJ2luY2x1ZGUnIDogJ29taXQnXG4gICAgfSlcbiAgICByZXR1cm4gaGFuZGxlRmV0Y2gocHJvbWlzZSlcbn1cblxuLyoqXG4gKiBSZXF1ZXN0IFBheWxvYWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvb2tpZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9zdCh1cmwsIGRhdGEsIGhlYWRlcnMsIGNvb2tpZSkge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKVxuICAgIGNvbnN0IHByb21pc2UgPSBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC10eXBlJzogQ09OVEVOVF9UWVBFWydKU09OJ10sXG4gICAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiBjb29raWUgPyAnaW5jbHVkZScgOiAnb21pdCdcbiAgICB9KVxuICAgIHJldHVybiBoYW5kbGVGZXRjaChwcm9taXNlKVxufVxuXG4vKipcbiAqIEZvcm0gRGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7Kn0gZm9ybURhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvb2tpZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybSh1cmwsIGZvcm1EYXRhLCBoZWFkZXJzLCBjb29raWUpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybClcbiAgICBjb25zdCBwcm9taXNlID0gZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtdHlwZSc6IENPTlRFTlRfVFlQRVsnRk9STSddLFxuICAgICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogY29va2llID8gJ2luY2x1ZGUnIDogJ29taXQnXG4gICAgfSlcbiAgICByZXR1cm4gaGFuZGxlRmV0Y2gocHJvbWlzZSlcbn1cbiIsImltcG9ydCB7UmVpeHMsIFJlaXhzQWxsfSBmcm9tICcuL2NvcmUvY29uc3RydWN0b3InXG5cbi8qKlxuICogU2V0IHBpcGUgXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICogQHBhcmFtICB7Li4uYW55fSBmdW5MaXN0IFxuICovXG5mdW5jdGlvbiBzZXRQaXBlcyhuYW1lLCAuLi5mdW5MaXN0KSB7XG4gICAgZnVuTGlzdC5mb3JFYWNoKGZuPT57XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgIH0pXG4gICAgUmVpeHMuZ2xvYmFsW25hbWVdID0gWy4uLmZ1bkxpc3RdXG59XG5cbi8qKlxuICogU2V0IEludGVyY2VwdG9yXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuIFxuICovXG5mdW5jdGlvbiBzZXRJbnRlcmNlcHRvcihuYW1lLCBmdW4pIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIFJlaXhzLmdsb2JhbFtuYW1lXSA9IGZ1blxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICB9XG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBcbiAqIEBwYXJhbSB7Kn0gcGFyYW1zIFxuICovXG5mdW5jdGlvbiByZWl4cyh1cmwsIG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuICBuZXcgUmVpeHModXJsLCBtZXRob2QsIHBhcmFtcylcbn1cblxuLy8gcmVpeHMuYWxsXG5yZWl4cy5hbGwgPSAoLi4uc2NoZWR1bGVyKSA9PiBuZXcgUmVpeHNBbGwoLi4uc2NoZWR1bGVyKVxuXG5cbi8vIFJlcGxhY2VkIGJ5IGJyb3dzZXJpZnktdmVyc2lvbmlmeSB0cmFuc2Zvcm1cbnJlaXhzLnZlcnNpb24gPSAnX19WRVJTSU9OX18nXG5cbi8vIFNldCByZXF1ZXN0IGFuZCByZXNwb25zZSBwaXBlXG5yZWl4cy5yZXFQaXBlcyA9IHNldFBpcGVzLmJpbmQobnVsbCwgJ3JlcVBpcGVzJylcbnJlaXhzLnJlc1BpcGVzID0gc2V0UGlwZXMuYmluZChudWxsLCAncmVzUGlwZXMnKVxuXG4vLyBTZXQgcmVxdWVzdCBhbmQgcmVzcG9uc2UgaW50ZXJjZXB0b3JcbnJlaXhzLmJlZm9yZVJlcSA9IHNldEludGVyY2VwdG9yLmJpbmQobnVsbCwgJ2JlZm9yZVJlcScpXG5yZWl4cy5hZnRlclJlcSA9IHNldEludGVyY2VwdG9yLmJpbmQobnVsbCwgJ2FmdGVyUmVxJylcbnJlaXhzLmJlZm9yZVJlcyA9IHNldEludGVyY2VwdG9yLmJpbmQobnVsbCwgJ2JlZm9yZVJlcycpXG5yZWl4cy5hZnRlclJlcyA9IHNldEludGVyY2VwdG9yLmJpbmQobnVsbCwgJ2FmdGVyUmVzJylcblxuLy8gU2V0IGdsb2JhbCBoZWFkZXJcblJlZmxlY3QuZGVmaW5lUHJvcGVydHkocmVpeHMsICdnbG9iYWxIZWFkZXInLCB7XG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIFJlaXhzLmdsb2JhbC5nbG9iYWxIZWFkZXIgPSB2YWx1ZVxuICAgIH1cbn0pXG5cbi8vIFNldCBnbG9iYWwgcGFyYW1zXG5SZWZsZWN0LmRlZmluZVByb3BlcnR5KHJlaXhzLCAnZ2xvYmFsUGFyYW1zJywge1xuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBSZWl4cy5nbG9iYWwuZ2xvYmFsUGFyYW1zID0gdmFsdWVcbiAgICB9XG59KVxuXG5leHBvcnQgZGVmYXVsdCByZWl4c1xuXG5cbiIsImV4cG9ydCBjb25zdCBNRVRIT0RfVFlQRVMgPSBbXG4gICAgJ2dldCcsXG4gICAgJ3Bvc3QnLFxuICAgICdmb3JtJyxcbiAgICAncHVzaCdcbl1cblxuZXhwb3J0IGNvbnN0IENPTlRFTlRfVFlQRSA9IHtcbiAgICBKU09OOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JyxcbiAgICBGT1JNOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04J1xufSIsIi8qKlxuICogRGF0YSBwcm9jZXNzaW5nXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YUZpbHRlcmluZyhwaXBlcywgZGF0YSkge1xuICAgIGNvbnN0IG5ld0RhdGEgPSBbZGF0YSwgLi4ucGlwZXNdLnJlZHVjZSgocHJldiwgY3VyKT0+Y3VyKHByZXYpKVxuICAgIHJldHVybiBuZXdEYXRhXG59Il19"}