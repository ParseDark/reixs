{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js","node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","node_modules/@babel/runtime/helpers/assertThisInitialized.js","node_modules/@babel/runtime/helpers/asyncToGenerator.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/interopRequireWildcard.js","node_modules/@babel/runtime/helpers/iterableToArray.js","node_modules/@babel/runtime/helpers/nonIterableSpread.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/setPrototypeOf.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/typeof.js","node_modules/@babel/runtime/regenerator/index.js","node_modules/regenerator-runtime/runtime.js","src/core/constructor/handler.js","src/core/constructor/index.js","src/core/constructor/separate.js","src/core/create-request/index.js","src/core/create-request/mark-map.js","src/core/request/handle-fetch.js","src/core/request/index.js","src/reixs.js","src/shared/constants.js","src/shared/utils.js"],"names":[],"mappings":"AAAA;;;ACAA,MAAM,CAAC,OAAP,GAAiB,OAAO,CAAC,aAAD,CAAP,WAAjB;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACttBA;;;;;;;;SAKI,O,GAAU;AACN,MAAA,QAAQ,EAAE,KADJ;AAE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","file":"reixs.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports = require('./src/reixs').default","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","function _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nmodule.exports = _interopRequireWildcard;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","/**\n * The underlying request model\n */\nexport default class {\n    // Request trigger rule configuration\n    _config = {\n        throttle: false,\n        debounce: 0,\n        audit: false,\n        overtime: null\n    }\n\n    // Life cycle function\n    _hook = {\n        tartHook: null,\n        endHook: null,\n        errorHook: null\n    }\n\n    // Data filtering\n    _pipes = {\n        reqPipes: [],\n        resPipes: []\n    }\n\n    // Task queue executed after the request is completed\n    _taskList =[]\n\n    /**\n     * Circular call task\n     * @param {*} data \n     */\n    _execute(data) {\n        const {errorHook} = this._hook\n        if (data !== undefined) {\n            try {\n                this._taskList.forEach(task =>{\n                    task(data)\n                })\n            } catch (error) {\n                errorHook && errorHook(error)\n            }\n        }\n    }\n    \n    /**\n     * Set the request filter pipeline\n     * \n     * @param  {...any} pipes \n     */\n    reqPipes(...pipes) {\n        if (pipes.find(pipe =>typeof pipe !== 'function')) {\n            throw new Error('Pipe must be a function')\n        } else {\n            this._pipes.reqPipes = [...pipes]\n        }\n        return this\n    }\n\n    /**\n     * Set the response filter pipeline\n     * \n     * @param  {...any} pipes \n     */\n    resPipes(...pipes) {\n        if (pipes.find(pipe =>typeof pipe !== 'function')) {\n            throw new Error('Pipe must be a function')\n        } else {\n            this._pipes.resPipes = [...pipes]\n        }\n        return this\n    }\n\n    /**\n     * Set throttle\n     * \n     * @param {number|boolean} settings \n     */\n    throttle(settings) {\n        if (typeof time === 'number' || typeof time === 'boolean') {\n            this._config.throttle = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Set debounce\n     * \n     * @param {number|boolean} settings \n     */\n    debounce(settings) {\n        if (typeof settings === 'number' || typeof settings === 'boolean') {\n            this._config.debounce = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set audit\n     * \n     * @param {number|boolean} settings \n     */\n    audit(settings) {\n        if (typeof settings === 'number' || typeof settings === 'boolean') {\n            this._config.audit = settings\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set overtime\n     * \n     * @param {number|null} time \n     */\n    overtime(time) {\n        if (typeof time === 'number' || time === null) {\n            this._config.overtime = time\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Add task\n     * \n     * @param {Function} task \n     */\n    task(task) {\n        if (typeof task === 'function') {\n            this._taskList.push(task)\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n\n    /**\n     * Request to start\n     * \n     * @param {Function} startHook \n     */\n    start(startHook) {\n        if (typeof startHook === 'function') {\n            this._hook.startHook = startHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Request to end\n     * \n     * @param {Function} endHook \n     */\n    end(endHook) {\n        if (typeof endHook === 'function') {\n            this._hook.endHook = endHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Request to error\n     * \n     * @param {Function} errorHook \n     */\n    error(errorHook) {\n        if (typeof errorHook === 'function') {\n            this._hook.errorHook = errorHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n}\n\n","export * from './separate.js'","import {dataFiltering} from '../../shared/utils'\nimport {METHOD_TYPES} from '../../shared/constants'\n\nimport createRequest from '../create-request'\nimport * as request from '../request'\n\nimport Handler from './handler'\n\n/**\n *  Separate request object\n */\nclass SeparateHandler  extends Handler {\n    constructor(url, method = 'get', params = null) {\n        super()\n\n        // Initialize the http\n        this._http = {\n            ...this._http,\n            url,\n            params\n        }\n        this.setMethod(method)\n\n        // Create request function\n        this._initRequest()\n    }\n\n    // Multiple requests Shared\n    static global = {\n        globalHeader: {},\n        globalParams: {} \n\n    }\n\n    // Network request information\n    _http = {\n        url: '',\n        method: null,\n        header: {},\n        params: null,\n        cookie: true\n    }\n    \n    /**\n     * Complete request header\n     * \n     * @return {Object} \n     */\n    get requesetHeader() {\n        const {header} = this._http\n        const {globalHeader} = this.constructor.global\n        return {\n            ...globalHeader, \n            ...header\n        }\n    }\n    \n    /**\n     * Complete request parameters\n     * \n     * @param {Object} params \n     */\n    _getParams(params) {\n        const {globalParams} = this.constructor.global\n        return {\n            ...globalParams, \n            ...params\n        }\n    }\n\n    /**\n     * Create request function\n     */\n    _initRequest() {\n        const {_config, _sendRequest, _execute, _hook} = this\n        this.request = createRequest(\n            _config, \n            _sendRequest.bind(this), \n            _execute.bind(this), \n            _hook\n        )\n    }\n\n    /**\n     * Set the request url\n     * \n     * @param {string} url \n     */\n    setUrl(url) {\n        if (typeof url === 'string') {\n            this._http.url = url\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set the request header\n     * \n     * @param {Object} header \n     */\n    setHeader(header) {\n        if (header.constructor === Object) {\n            this._http.header = header\n        } else {\n            throw new Error('Header invalid setting')\n        }\n        return this\n    }\n\n    /**\n     * Set request parameters\n     * \n     * @param {*} params \n     */\n    setParams(params) {\n        this._http.params = params\n        return this\n    }\n    \n    /**\n     * Set whether to carry cookies\n     * \n     * @param {boolean} ifCookie \n     */\n    setCookie(ifCookie) {\n        if (typeof ifCookie === 'boolean') {\n            this._http.cookie = ifCookie\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Set the request method\n     * \n     * @param {string} method \n     */\n    setMethod(method = null) {\n        method = method.toLowerCase()\n        if (METHOD_TYPES.includes(method)) {\n            this._http.method = method\n        } else {\n            throw new Error('Invalid method')\n        }\n        return this\n    }\n    \n    /**\n     * Send the request to the server\n     * \n     * @param {*} params \n     * @param {string} type \n     */\n    async _sendRequest(params = this._http.params, type) {\n        const {url, method, cookie} = this._http\n        const {errorHook} = this._hook\n        const {reqPipes, resPipes} = this._pipes\n\n        const requestType = type ? type : method\n        const requestParams = requestType === 'push' \n            ? params : this._getParams(params)\n\n        const data = await request[requestType](\n            url, \n            dataFiltering(reqPipes, requestParams, errorHook),\n            this.requesetHeader,\n            cookie\n        )\n        return dataFiltering(resPipes, data, errorHook)\n    }\n}\n\n\n// Bind request category \nMETHOD_TYPES.map(requestType=>{\n    SeparateHandler.prototype[requestType] = function(params) {\n        this.request(params, requestType)\n    }\n})\n \n\nexport default SeparateHandler","import MarkMap from './mark-map'\n\n/**\n * Create delay promise\n * \n * @param {number} time \n */\nfunction createWait(time) {\n    return time === 0 ? Promise.resolve()\n        : new Promise(resolve=>{\n            setTimeout(()=>resolve(), time)\n        })\n}\n\n/**\n * Detect timeout\n * \n * @param {Promise} promise \n * @param {null|number} time \n */\nfunction requestTimer(promise, time) {\n    const request = promise.then(data=>({\n        timeout: false, \n        data\n    }))\n    const timer = createWait(time).then(()=>({\n        timeout: true, \n        data: null\n    }))\n    return time === null ? request\n        : Promise.race([request, timer])\n}\n\n/**\n * The method to create the request\n * \n * @param {Object} config \n * @param {Function} sendRequest \n * @param {Array} execute \n * @param {Object} hook \n */\nexport default function(config, sendRequest, execute, hook) {\n    const markMap = new MarkMap()\n    return async function(...par) {\n        const {startHook, endHook} = hook\n        const {audit, overtime} = config\n        startHook && startHook(...par)\n        let mark\n        if (audit) {\n            mark = markMap.get(audit)\n        }\n        const {timeout, data} = await requestTimer(sendRequest(...par), overtime)\n        // If audit is set, the duplicate request is discarded\n        if (!audit || markMap.test(mark)) {\n            // If the timeout occurs, the task is not processed\n            if (!timeout) {\n                execute(data)\n            }\n            endHook && endHook()\n        }\n    }\n}","\n\n/**\n * Create a signature object\n * \n * @param {symbol} sym \n * @param {number} time \n */\nfunction createSign(sym, time) {\n    const sign = Object.create(null)\n    sign.sym = sym\n    sign.time = time\n    return sign\n}\n\n/**\n * Create a mark object\n * \n * @param {Object} sign \n */\nfunction createMark(sign) {\n    const mark = Object.create(null)\n    mark.sign = sign\n    mark.sym = sign.sym\n    return mark\n}\n\n/**\n * Verify that mark is deprecated\n */\nexport default class {\n    _map = []\n\n    /**\n     * Get mark\n     * @param {number|boolean} audit \n     */\n    get(audit) {\n        const {_map} = this\n        if (audit) {\n            const sym = Symbol()\n            const time = Date.now()\n            let sign\n            if (!_map.length \n                || (time - _map[_map.length - 1].time > audit \n                    && audit !== true)\n            ) {\n                sign = createSign(sym, time)\n                _map.push(sign)\n            } else {\n                sign = _map[_map.length - 1]\n                sign.sym = sym\n                sign.time = time\n            }\n\n            return createMark(sign)\n        }\n        return null\n    }\n\n    /**\n     * Verify the mark\n     * @param {Object} mark \n     */\n    test(mark) {\n        if (mark && mark.sym !== mark.sign.sym) {\n            return false\n        } \n\n        if (mark) {\n            const {_map} = this\n            const index = _map.indexOf(mark.sign)\n            _map.splice(index, 1)\n        }\n        return true\n    }\n}","\n/**\n * Check for success\n * \n * @param {Object} response \n */\nfunction checkStatus(response) {\n    if (response.status >= 200 && response.status < 300) {\n        const contentType = response.headers.get('content-type')\n        if (contentType && contentType.includes('application/json')) {\n            return response.json()\n        } else {\n            return response.text()\n        }\n    } else {\n        throw new Error()\n    }\n}\n\n/**\n * Handle fetch\n * \n * @param {Object} promise \n */\nexport default function handleFetch(promise) {\n    return promise\n        .then(response => checkStatus(response))\n        .catch(error => {\n            throw error\n        })\n}","import {CONTENT_TYPE} from '../../shared/constants'\nimport handleFetch from './handle-fetch'\n\n\n/**\n * Query String Parameters\n * \n * @param {string} url \n * @param {*} params \n * @param {Object} headers \n * @param {boolean} cookie \n */\nexport function get(url, params, headers, cookie) {\n    url = new URL(url)\n    Object.keys(params)\n        .forEach(key => url.searchParams.append(key, params[key]))\n    const promise = fetch(url, {\n        method: 'GET',\n        headers: {\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Dynamic Router\n * \n * @param {string} url \n * @param {*} params \n * @param {Object} headers \n * @param {boolean} cookie \n */\nexport function push(url, params, headers, cookie) {\n    url = new URL(url)\n    url.pathname += `/${params}`\n    const promise = fetch(url, {\n        method: 'GET',\n        headers: {\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Request Payload\n * \n * @param {string} url \n * @param {*} params \n * @param {Object} headers \n * @param {boolean} cookie \n */\nexport function post(url, params, headers, cookie) {\n    url = new URL(url)\n    const promise = fetch(url, {\n        method: 'POST',\n        body: JSON.stringify(params),\n        headers: {\n            'Content-type': CONTENT_TYPE['JSON'],\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n\n/**\n * Form Data\n * \n * @param {string} url \n * @param {*} params \n * @param {Object} headers \n * @param {boolean} cookie \n */\nexport function form(url, params, headers, cookie) {\n    url = new URL(url)\n    const promise = fetch(url, {\n        method: 'POST',\n        body: JSON.stringify(params),\n        headers: {\n            'Content-type': CONTENT_TYPE['FORM'],\n            ...headers\n        },\n        credentials: cookie ? 'include' : 'omit'\n    })\n    return handleFetch(promise)\n}\n","import {Separate} from './core/constructor'\n\n/**\n * Create reixs \n * \n * @param {string} url \n * @param {string} method\n * @param {*} params  \n */\nfunction createInstance(url, method, params) {\n    return new Proxy(new Separate(url, method, params), {\n        set() {\n            throw new Error('Overwriting any attributes is not allowed')\n        }\n    })\n}\n\n/**\n * Set pipe \n * \n * @param {string} name \n * @param  {...any} funList \n */\nfunction setPipes(name, ...funList) {\n    Separate.globalPipes[name] = [...funList]\n}\n\nexport default new Proxy(createInstance, {\n    get(target, property) {\n        switch (property) {\n        // Replaced by browserify-versionify transform\n        case 'version':\n            return '__VERSION__'\n            // Set request and response pipe\n        case 'reqPipes':\n        case 'resPipes':\n            return setPipes.bind(null, property)\n        }\n    },\n    set(target, property, value) {\n        Separate.global[property] = value\n    }\n})\n\n\n","export const METHOD_TYPES = [\n    'get',\n    'post',\n    'form',\n    'push'\n]\n\nexport const CONTENT_TYPE = {\n    JSON: 'application/json;charset=UTF-8',\n    FORM: 'application/x-www-form-urlencoded; charset=UTF-8'\n}","/**\n * Data processing\n *\n * @param {*} data \n */\nexport function dataFiltering(pipes, data, errorHook) {\n    try {\n        const newData = [data, ...pipes].reduce((prev, cur)=>cur(prev))\n        return newData\n    } catch (error) {\n        errorHook(error)\n    }\n}"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwic3JjL2NvcmUvY29uc3RydWN0b3IvaGFuZGxlci5qcyIsInNyYy9jb3JlL2NvbnN0cnVjdG9yL2luZGV4LmpzIiwic3JjL2NvcmUvY29uc3RydWN0b3Ivc2VwYXJhdGUuanMiLCJzcmMvY29yZS9jcmVhdGUtcmVxdWVzdC9pbmRleC5qcyIsInNyYy9jb3JlL2NyZWF0ZS1yZXF1ZXN0L21hcmstbWFwLmpzIiwic3JjL2NvcmUvcmVxdWVzdC9oYW5kbGUtZmV0Y2guanMiLCJzcmMvY29yZS9yZXF1ZXN0L2luZGV4LmpzIiwic3JjL3JlaXhzLmpzIiwic3JjL3NoYXJlZC9jb25zdGFudHMuanMiLCJzcmMvc2hhcmVkL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNBQSxNQUFNLENBQUMsT0FBUCxHQUFpQixPQUFPLENBQUMsYUFBRCxDQUFQLFdBQWpCOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3R0QkE7Ozs7Ozs7O1NBS0ksTyxHQUFVO0FBQ04sTUFBQSxRQUFRLEVBQUUsS0FESjtBQUVOLE1BQUEsUUFBUSxFQUFFLENBRko7QUFHTixNQUFBLEtBQUssRUFBRSxLQUhEO0FBSU4sTUFBQSxRQUFRLEVBQUUsSUFKSixDQU9WOztBQVBVLEs7U0FRVixLLEdBQVE7QUFDSixNQUFBLFFBQVEsRUFBRSxJQUROO0FBRUosTUFBQSxPQUFP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QUFLLFVBQUw7QUFDSSxlQUFPLFFBQVEsQ0FBQyxJQUFULENBQWMsSUFBZCxFQUFvQixRQUFwQixDQUFQO0FBUEo7QUFTSCxHQVhvQztBQVlyQyxFQUFBLEdBWnFDLGVBWWpDLE1BWmlDLEVBWXpCLFFBWnlCLEVBWWYsS0FaZSxFQVlSO0FBQ3pCLDBCQUFTLE1BQVQsQ0FBZ0IsUUFBaEIsSUFBNEIsS0FBNUI7QUFDSDtBQWRvQyxDQUExQixDOzs7Ozs7Ozs7OztBQzNCUixJQUFNLFlBQVksR0FBRyxDQUN4QixLQUR3QixFQUV4QixNQUZ3QixFQUd4QixNQUh3QixFQUl4QixNQUp3QixDQUFyQjs7QUFPQSxJQUFNLFlBQVksR0FBRztBQUN4QixFQUFBLElBQUksRUFBRSxnQ0FEa0I7QUFFeEIsRUFBQSxJQUFJLEVBQUU7QUFGa0IsQ0FBckI7Ozs7Ozs7Ozs7Ozs7OztBQ1BQOzs7OztBQUtPLFNBQVMsYUFBVCxDQUF1QixLQUF2QixFQUE4QixJQUE5QixFQUFvQyxTQUFwQyxFQUErQztBQUNsRCxNQUFJO0FBQ0EsUUFBTSxPQUFPLEdBQUcsQ0FBQyxJQUFELDZDQUFVLEtBQVYsR0FBaUIsTUFBakIsQ0FBd0IsVUFBQyxJQUFELEVBQU8sR0FBUDtBQUFBLGFBQWEsR0FBRyxDQUFDLElBQUQsQ0FBaEI7QUFBQSxLQUF4QixDQUFoQjtBQUNBLFdBQU8sT0FBUDtBQUNILEdBSEQsQ0FHRSxPQUFPLEtBQVAsRUFBYztBQUNaLElBQUEsU0FBUyxDQUFDLEtBQUQsQ0FBVDtBQUNIO0FBQ0oiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3JjL3JlaXhzJykuZGVmYXVsdCIsImZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV3T2JqID0ge307XG5cbiAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTtcblxuICAgICAgICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqO1xuICAgIHJldHVybiBuZXdPYmo7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZjIgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YyKG9iaik7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mMihTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwiLyoqXG4gKiBUaGUgdW5kZXJseWluZyByZXF1ZXN0IG1vZGVsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgICAvLyBSZXF1ZXN0IHRyaWdnZXIgcnVsZSBjb25maWd1cmF0aW9uXG4gICAgX2NvbmZpZyA9IHtcbiAgICAgICAgdGhyb3R0bGU6IGZhbHNlLFxuICAgICAgICBkZWJvdW5jZTogMCxcbiAgICAgICAgYXVkaXQ6IGZhbHNlLFxuICAgICAgICBvdmVydGltZTogbnVsbFxuICAgIH1cblxuICAgIC8vIExpZmUgY3ljbGUgZnVuY3Rpb25cbiAgICBfaG9vayA9IHtcbiAgICAgICAgdGFydEhvb2s6IG51bGwsXG4gICAgICAgIGVuZEhvb2s6IG51bGwsXG4gICAgICAgIGVycm9ySG9vazogbnVsbFxuICAgIH1cblxuICAgIC8vIERhdGEgZmlsdGVyaW5nXG4gICAgX3BpcGVzID0ge1xuICAgICAgICByZXFQaXBlczogW10sXG4gICAgICAgIHJlc1BpcGVzOiBbXVxuICAgIH1cblxuICAgIC8vIFRhc2sgcXVldWUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIHJlcXVlc3QgaXMgY29tcGxldGVkXG4gICAgX3Rhc2tMaXN0ID1bXVxuXG4gICAgLyoqXG4gICAgICogQ2lyY3VsYXIgY2FsbCB0YXNrXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFxuICAgICAqL1xuICAgIF9leGVjdXRlKGRhdGEpIHtcbiAgICAgICAgY29uc3Qge2Vycm9ySG9va30gPSB0aGlzLl9ob29rXG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFza0xpc3QuZm9yRWFjaCh0YXNrID0+e1xuICAgICAgICAgICAgICAgICAgICB0YXNrKGRhdGEpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JIb29rICYmIGVycm9ySG9vayhlcnJvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHJlcXVlc3QgZmlsdGVyIHBpcGVsaW5lXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBwaXBlcyBcbiAgICAgKi9cbiAgICByZXFQaXBlcyguLi5waXBlcykge1xuICAgICAgICBpZiAocGlwZXMuZmluZChwaXBlID0+dHlwZW9mIHBpcGUgIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpcGUgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BpcGVzLnJlcVBpcGVzID0gWy4uLnBpcGVzXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXNwb25zZSBmaWx0ZXIgcGlwZWxpbmVcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IHBpcGVzIFxuICAgICAqL1xuICAgIHJlc1BpcGVzKC4uLnBpcGVzKSB7XG4gICAgICAgIGlmIChwaXBlcy5maW5kKHBpcGUgPT50eXBlb2YgcGlwZSAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGlwZSBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGlwZXMucmVzUGlwZXMgPSBbLi4ucGlwZXNdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhyb3R0bGVcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcnxib29sZWFufSBzZXR0aW5ncyBcbiAgICAgKi9cbiAgICB0aHJvdHRsZShzZXR0aW5ncykge1xuICAgICAgICBpZiAodHlwZW9mIHRpbWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB0aW1lID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy50aHJvdHRsZSA9IHNldHRpbmdzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGVib3VuY2VcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcnxib29sZWFufSBzZXR0aW5ncyBcbiAgICAgKi9cbiAgICBkZWJvdW5jZShzZXR0aW5ncykge1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc2V0dGluZ3MgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLmRlYm91bmNlID0gc2V0dGluZ3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBTZXQgYXVkaXRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcnxib29sZWFufSBzZXR0aW5ncyBcbiAgICAgKi9cbiAgICBhdWRpdChzZXR0aW5ncykge1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc2V0dGluZ3MgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLmF1ZGl0ID0gc2V0dGluZ3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBTZXQgb3ZlcnRpbWVcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcnxudWxsfSB0aW1lIFxuICAgICAqL1xuICAgIG92ZXJ0aW1lKHRpbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lID09PSAnbnVtYmVyJyB8fCB0aW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcub3ZlcnRpbWUgPSB0aW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQWRkIHRhc2tcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0YXNrIFxuICAgICAqL1xuICAgIHRhc2sodGFzaykge1xuICAgICAgICBpZiAodHlwZW9mIHRhc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rhc2tMaXN0LnB1c2godGFzaylcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHRvIHN0YXJ0XG4gICAgICogXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RhcnRIb29rIFxuICAgICAqL1xuICAgIHN0YXJ0KHN0YXJ0SG9vaykge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXJ0SG9vayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5faG9vay5zdGFydEhvb2sgPSBzdGFydEhvb2tcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0byBlbmRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmRIb29rIFxuICAgICAqL1xuICAgIGVuZChlbmRIb29rKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kSG9vayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5faG9vay5lbmRIb29rID0gZW5kSG9va1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHRvIGVycm9yXG4gICAgICogXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3JIb29rIFxuICAgICAqL1xuICAgIGVycm9yKGVycm9ySG9vaykge1xuICAgICAgICBpZiAodHlwZW9mIGVycm9ySG9vayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5faG9vay5lcnJvckhvb2sgPSBlcnJvckhvb2tcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsImV4cG9ydCAqIGZyb20gJy4vc2VwYXJhdGUuanMnIiwiaW1wb3J0IHtkYXRhRmlsdGVyaW5nfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMnXG5pbXBvcnQge01FVEhPRF9UWVBFU30gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cydcblxuaW1wb3J0IGNyZWF0ZVJlcXVlc3QgZnJvbSAnLi4vY3JlYXRlLXJlcXVlc3QnXG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJy4uL3JlcXVlc3QnXG5cbmltcG9ydCBIYW5kbGVyIGZyb20gJy4vaGFuZGxlcidcblxuLyoqXG4gKiAgU2VwYXJhdGUgcmVxdWVzdCBvYmplY3RcbiAqL1xuY2xhc3MgU2VwYXJhdGVIYW5kbGVyICBleHRlbmRzIEhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbWV0aG9kID0gJ2dldCcsIHBhcmFtcyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoKVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGh0dHBcbiAgICAgICAgdGhpcy5faHR0cCA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2h0dHAsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE1ldGhvZChtZXRob2QpXG5cbiAgICAgICAgLy8gQ3JlYXRlIHJlcXVlc3QgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5faW5pdFJlcXVlc3QoKVxuICAgIH1cblxuICAgIC8vIE11bHRpcGxlIHJlcXVlc3RzIFNoYXJlZFxuICAgIHN0YXRpYyBnbG9iYWwgPSB7XG4gICAgICAgIGdsb2JhbEhlYWRlcjoge30sXG4gICAgICAgIGdsb2JhbFBhcmFtczoge30gXG5cbiAgICB9XG5cbiAgICAvLyBOZXR3b3JrIHJlcXVlc3QgaW5mb3JtYXRpb25cbiAgICBfaHR0cCA9IHtcbiAgICAgICAgdXJsOiAnJyxcbiAgICAgICAgbWV0aG9kOiBudWxsLFxuICAgICAgICBoZWFkZXI6IHt9LFxuICAgICAgICBwYXJhbXM6IG51bGwsXG4gICAgICAgIGNvb2tpZTogdHJ1ZVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSByZXF1ZXN0IGhlYWRlclxuICAgICAqIFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gXG4gICAgICovXG4gICAgZ2V0IHJlcXVlc2V0SGVhZGVyKCkge1xuICAgICAgICBjb25zdCB7aGVhZGVyfSA9IHRoaXMuX2h0dHBcbiAgICAgICAgY29uc3Qge2dsb2JhbEhlYWRlcn0gPSB0aGlzLmNvbnN0cnVjdG9yLmdsb2JhbFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZ2xvYmFsSGVhZGVyLCBcbiAgICAgICAgICAgIC4uLmhlYWRlclxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIHJlcXVlc3QgcGFyYW1ldGVyc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgXG4gICAgICovXG4gICAgX2dldFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3Qge2dsb2JhbFBhcmFtc30gPSB0aGlzLmNvbnN0cnVjdG9yLmdsb2JhbFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZ2xvYmFsUGFyYW1zLCBcbiAgICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHJlcXVlc3QgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBfaW5pdFJlcXVlc3QoKSB7XG4gICAgICAgIGNvbnN0IHtfY29uZmlnLCBfc2VuZFJlcXVlc3QsIF9leGVjdXRlLCBfaG9va30gPSB0aGlzXG4gICAgICAgIHRoaXMucmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoXG4gICAgICAgICAgICBfY29uZmlnLCBcbiAgICAgICAgICAgIF9zZW5kUmVxdWVzdC5iaW5kKHRoaXMpLCBcbiAgICAgICAgICAgIF9leGVjdXRlLmJpbmQodGhpcyksIFxuICAgICAgICAgICAgX2hvb2tcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcmVxdWVzdCB1cmxcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFxuICAgICAqL1xuICAgIHNldFVybCh1cmwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9odHRwLnVybCA9IHVybFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcmVxdWVzdCBoZWFkZXJcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyIFxuICAgICAqL1xuICAgIHNldEhlYWRlcihoZWFkZXIpIHtcbiAgICAgICAgaWYgKGhlYWRlci5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9odHRwLmhlYWRlciA9IGhlYWRlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkZXIgaW52YWxpZCBzZXR0aW5nJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCByZXF1ZXN0IHBhcmFtZXRlcnNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0geyp9IHBhcmFtcyBcbiAgICAgKi9cbiAgICBzZXRQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX2h0dHAucGFyYW1zID0gcGFyYW1zXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFNldCB3aGV0aGVyIHRvIGNhcnJ5IGNvb2tpZXNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlmQ29va2llIFxuICAgICAqL1xuICAgIHNldENvb2tpZShpZkNvb2tpZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlmQ29va2llID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAuY29va2llID0gaWZDb29raWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcmVxdWVzdCBtZXRob2RcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFxuICAgICAqL1xuICAgIHNldE1ldGhvZChtZXRob2QgPSBudWxsKSB7XG4gICAgICAgIG1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlmIChNRVRIT0RfVFlQRVMuaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgICAgICAgdGhpcy5faHR0cC5tZXRob2QgPSBtZXRob2RcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIHJlcXVlc3QgdG8gdGhlIHNlcnZlclxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gcGFyYW1zIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFxuICAgICAqL1xuICAgIGFzeW5jIF9zZW5kUmVxdWVzdChwYXJhbXMgPSB0aGlzLl9odHRwLnBhcmFtcywgdHlwZSkge1xuICAgICAgICBjb25zdCB7dXJsLCBtZXRob2QsIGNvb2tpZX0gPSB0aGlzLl9odHRwXG4gICAgICAgIGNvbnN0IHtlcnJvckhvb2t9ID0gdGhpcy5faG9va1xuICAgICAgICBjb25zdCB7cmVxUGlwZXMsIHJlc1BpcGVzfSA9IHRoaXMuX3BpcGVzXG5cbiAgICAgICAgY29uc3QgcmVxdWVzdFR5cGUgPSB0eXBlID8gdHlwZSA6IG1ldGhvZFxuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gcmVxdWVzdFR5cGUgPT09ICdwdXNoJyBcbiAgICAgICAgICAgID8gcGFyYW1zIDogdGhpcy5fZ2V0UGFyYW1zKHBhcmFtcylcblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVxdWVzdFtyZXF1ZXN0VHlwZV0oXG4gICAgICAgICAgICB1cmwsIFxuICAgICAgICAgICAgZGF0YUZpbHRlcmluZyhyZXFQaXBlcywgcmVxdWVzdFBhcmFtcywgZXJyb3JIb29rKSxcbiAgICAgICAgICAgIHRoaXMucmVxdWVzZXRIZWFkZXIsXG4gICAgICAgICAgICBjb29raWVcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gZGF0YUZpbHRlcmluZyhyZXNQaXBlcywgZGF0YSwgZXJyb3JIb29rKVxuICAgIH1cbn1cblxuXG4vLyBCaW5kIHJlcXVlc3QgY2F0ZWdvcnkgXG5NRVRIT0RfVFlQRVMubWFwKHJlcXVlc3RUeXBlPT57XG4gICAgU2VwYXJhdGVIYW5kbGVyLnByb3RvdHlwZVtyZXF1ZXN0VHlwZV0gPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KHBhcmFtcywgcmVxdWVzdFR5cGUpXG4gICAgfVxufSlcbiBcblxuZXhwb3J0IGRlZmF1bHQgU2VwYXJhdGVIYW5kbGVyIiwiaW1wb3J0IE1hcmtNYXAgZnJvbSAnLi9tYXJrLW1hcCdcblxuLyoqXG4gKiBDcmVhdGUgZGVsYXkgcHJvbWlzZVxuICogXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV2FpdCh0aW1lKSB7XG4gICAgcmV0dXJuIHRpbWUgPT09IDAgPyBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICA6IG5ldyBQcm9taXNlKHJlc29sdmU9PntcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PnJlc29sdmUoKSwgdGltZSlcbiAgICAgICAgfSlcbn1cblxuLyoqXG4gKiBEZXRlY3QgdGltZW91dFxuICogXG4gKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgXG4gKiBAcGFyYW0ge251bGx8bnVtYmVyfSB0aW1lIFxuICovXG5mdW5jdGlvbiByZXF1ZXN0VGltZXIocHJvbWlzZSwgdGltZSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBwcm9taXNlLnRoZW4oZGF0YT0+KHtcbiAgICAgICAgdGltZW91dDogZmFsc2UsIFxuICAgICAgICBkYXRhXG4gICAgfSkpXG4gICAgY29uc3QgdGltZXIgPSBjcmVhdGVXYWl0KHRpbWUpLnRoZW4oKCk9Pih7XG4gICAgICAgIHRpbWVvdXQ6IHRydWUsIFxuICAgICAgICBkYXRhOiBudWxsXG4gICAgfSkpXG4gICAgcmV0dXJuIHRpbWUgPT09IG51bGwgPyByZXF1ZXN0XG4gICAgICAgIDogUHJvbWlzZS5yYWNlKFtyZXF1ZXN0LCB0aW1lcl0pXG59XG5cbi8qKlxuICogVGhlIG1ldGhvZCB0byBjcmVhdGUgdGhlIHJlcXVlc3RcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNlbmRSZXF1ZXN0IFxuICogQHBhcmFtIHtBcnJheX0gZXhlY3V0ZSBcbiAqIEBwYXJhbSB7T2JqZWN0fSBob29rIFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb25maWcsIHNlbmRSZXF1ZXN0LCBleGVjdXRlLCBob29rKSB7XG4gICAgY29uc3QgbWFya01hcCA9IG5ldyBNYXJrTWFwKClcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4ucGFyKSB7XG4gICAgICAgIGNvbnN0IHtzdGFydEhvb2ssIGVuZEhvb2t9ID0gaG9va1xuICAgICAgICBjb25zdCB7YXVkaXQsIG92ZXJ0aW1lfSA9IGNvbmZpZ1xuICAgICAgICBzdGFydEhvb2sgJiYgc3RhcnRIb29rKC4uLnBhcilcbiAgICAgICAgbGV0IG1hcmtcbiAgICAgICAgaWYgKGF1ZGl0KSB7XG4gICAgICAgICAgICBtYXJrID0gbWFya01hcC5nZXQoYXVkaXQpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge3RpbWVvdXQsIGRhdGF9ID0gYXdhaXQgcmVxdWVzdFRpbWVyKHNlbmRSZXF1ZXN0KC4uLnBhciksIG92ZXJ0aW1lKVxuICAgICAgICAvLyBJZiBhdWRpdCBpcyBzZXQsIHRoZSBkdXBsaWNhdGUgcmVxdWVzdCBpcyBkaXNjYXJkZWRcbiAgICAgICAgaWYgKCFhdWRpdCB8fCBtYXJrTWFwLnRlc3QobWFyaykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0aW1lb3V0IG9jY3VycywgdGhlIHRhc2sgaXMgbm90IHByb2Nlc3NlZFxuICAgICAgICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZShkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kSG9vayAmJiBlbmRIb29rKClcbiAgICAgICAgfVxuICAgIH1cbn0iLCJcblxuLyoqXG4gKiBDcmVhdGUgYSBzaWduYXR1cmUgb2JqZWN0XG4gKiBcbiAqIEBwYXJhbSB7c3ltYm9sfSBzeW0gXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2lnbihzeW0sIHRpbWUpIHtcbiAgICBjb25zdCBzaWduID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIHNpZ24uc3ltID0gc3ltXG4gICAgc2lnbi50aW1lID0gdGltZVxuICAgIHJldHVybiBzaWduXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbWFyayBvYmplY3RcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IHNpZ24gXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hcmsoc2lnbikge1xuICAgIGNvbnN0IG1hcmsgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgbWFyay5zaWduID0gc2lnblxuICAgIG1hcmsuc3ltID0gc2lnbi5zeW1cbiAgICByZXR1cm4gbWFya1xufVxuXG4vKipcbiAqIFZlcmlmeSB0aGF0IG1hcmsgaXMgZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gICAgX21hcCA9IFtdXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWFya1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IGF1ZGl0IFxuICAgICAqL1xuICAgIGdldChhdWRpdCkge1xuICAgICAgICBjb25zdCB7X21hcH0gPSB0aGlzXG4gICAgICAgIGlmIChhdWRpdCkge1xuICAgICAgICAgICAgY29uc3Qgc3ltID0gU3ltYm9sKClcbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpXG4gICAgICAgICAgICBsZXQgc2lnblxuICAgICAgICAgICAgaWYgKCFfbWFwLmxlbmd0aCBcbiAgICAgICAgICAgICAgICB8fCAodGltZSAtIF9tYXBbX21hcC5sZW5ndGggLSAxXS50aW1lID4gYXVkaXQgXG4gICAgICAgICAgICAgICAgICAgICYmIGF1ZGl0ICE9PSB0cnVlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IGNyZWF0ZVNpZ24oc3ltLCB0aW1lKVxuICAgICAgICAgICAgICAgIF9tYXAucHVzaChzaWduKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduID0gX21hcFtfbWFwLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgc2lnbi5zeW0gPSBzeW1cbiAgICAgICAgICAgICAgICBzaWduLnRpbWUgPSB0aW1lXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVNYXJrKHNpZ24pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgdGhlIG1hcmtcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFyayBcbiAgICAgKi9cbiAgICB0ZXN0KG1hcmspIHtcbiAgICAgICAgaWYgKG1hcmsgJiYgbWFyay5zeW0gIT09IG1hcmsuc2lnbi5zeW0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IFxuXG4gICAgICAgIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBjb25zdCB7X21hcH0gPSB0aGlzXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IF9tYXAuaW5kZXhPZihtYXJrLnNpZ24pXG4gICAgICAgICAgICBfbWFwLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbn0iLCJcbi8qKlxuICogQ2hlY2sgZm9yIHN1Y2Nlc3NcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFxuICovXG5mdW5jdGlvbiBjaGVja1N0YXR1cyhyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKVxuICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKClcbiAgICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGZldGNoXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9taXNlIFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoYW5kbGVGZXRjaChwcm9taXNlKSB7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gY2hlY2tTdGF0dXMocmVzcG9uc2UpKVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfSlcbn0iLCJpbXBvcnQge0NPTlRFTlRfVFlQRX0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cydcbmltcG9ydCBoYW5kbGVGZXRjaCBmcm9tICcuL2hhbmRsZS1mZXRjaCdcblxuXG4vKipcbiAqIFF1ZXJ5IFN0cmluZyBQYXJhbWV0ZXJzXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgXG4gKiBAcGFyYW0geyp9IHBhcmFtcyBcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIFxuICogQHBhcmFtIHtib29sZWFufSBjb29raWUgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQodXJsLCBwYXJhbXMsIGhlYWRlcnMsIGNvb2tpZSkge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKVxuICAgIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgICAgLmZvckVhY2goa2V5ID0+IHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgcGFyYW1zW2tleV0pKVxuICAgIGNvbnN0IHByb21pc2UgPSBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogY29va2llID8gJ2luY2x1ZGUnIDogJ29taXQnXG4gICAgfSlcbiAgICByZXR1cm4gaGFuZGxlRmV0Y2gocHJvbWlzZSlcbn1cblxuLyoqXG4gKiBEeW5hbWljIFJvdXRlclxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFxuICogQHBhcmFtIHsqfSBwYXJhbXMgXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVycyBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29va2llIFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaCh1cmwsIHBhcmFtcywgaGVhZGVycywgY29va2llKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgdXJsLnBhdGhuYW1lICs9IGAvJHtwYXJhbXN9YFxuICAgIGNvbnN0IHByb21pc2UgPSBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogY29va2llID8gJ2luY2x1ZGUnIDogJ29taXQnXG4gICAgfSlcbiAgICByZXR1cm4gaGFuZGxlRmV0Y2gocHJvbWlzZSlcbn1cblxuLyoqXG4gKiBSZXF1ZXN0IFBheWxvYWRcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBcbiAqIEBwYXJhbSB7Kn0gcGFyYW1zIFxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvb2tpZSBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvc3QodXJsLCBwYXJhbXMsIGhlYWRlcnMsIGNvb2tpZSkge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKVxuICAgIGNvbnN0IHByb21pc2UgPSBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcmFtcyksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LXR5cGUnOiBDT05URU5UX1RZUEVbJ0pTT04nXSxcbiAgICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgY3JlZGVudGlhbHM6IGNvb2tpZSA/ICdpbmNsdWRlJyA6ICdvbWl0J1xuICAgIH0pXG4gICAgcmV0dXJuIGhhbmRsZUZldGNoKHByb21pc2UpXG59XG5cbi8qKlxuICogRm9ybSBEYXRhXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgXG4gKiBAcGFyYW0geyp9IHBhcmFtcyBcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIFxuICogQHBhcmFtIHtib29sZWFufSBjb29raWUgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtKHVybCwgcGFyYW1zLCBoZWFkZXJzLCBjb29raWUpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybClcbiAgICBjb25zdCBwcm9taXNlID0gZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJhbXMpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC10eXBlJzogQ09OVEVOVF9UWVBFWydGT1JNJ10sXG4gICAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiBjb29raWUgPyAnaW5jbHVkZScgOiAnb21pdCdcbiAgICB9KVxuICAgIHJldHVybiBoYW5kbGVGZXRjaChwcm9taXNlKVxufVxuIiwiaW1wb3J0IHtTZXBhcmF0ZX0gZnJvbSAnLi9jb3JlL2NvbnN0cnVjdG9yJ1xuXG4vKipcbiAqIENyZWF0ZSByZWl4cyBcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7Kn0gcGFyYW1zICBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UodXJsLCBtZXRob2QsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJveHkobmV3IFNlcGFyYXRlKHVybCwgbWV0aG9kLCBwYXJhbXMpLCB7XG4gICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3ZlcndyaXRpbmcgYW55IGF0dHJpYnV0ZXMgaXMgbm90IGFsbG93ZWQnKVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuLyoqXG4gKiBTZXQgcGlwZSBcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG4gKiBAcGFyYW0gIHsuLi5hbnl9IGZ1bkxpc3QgXG4gKi9cbmZ1bmN0aW9uIHNldFBpcGVzKG5hbWUsIC4uLmZ1bkxpc3QpIHtcbiAgICBTZXBhcmF0ZS5nbG9iYWxQaXBlc1tuYW1lXSA9IFsuLi5mdW5MaXN0XVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgUHJveHkoY3JlYXRlSW5zdGFuY2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgIC8vIFJlcGxhY2VkIGJ5IGJyb3dzZXJpZnktdmVyc2lvbmlmeSB0cmFuc2Zvcm1cbiAgICAgICAgY2FzZSAndmVyc2lvbic6XG4gICAgICAgICAgICByZXR1cm4gJ19fVkVSU0lPTl9fJ1xuICAgICAgICAgICAgLy8gU2V0IHJlcXVlc3QgYW5kIHJlc3BvbnNlIHBpcGVcbiAgICAgICAgY2FzZSAncmVxUGlwZXMnOlxuICAgICAgICBjYXNlICdyZXNQaXBlcyc6XG4gICAgICAgICAgICByZXR1cm4gc2V0UGlwZXMuYmluZChudWxsLCBwcm9wZXJ0eSlcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIFNlcGFyYXRlLmdsb2JhbFtwcm9wZXJ0eV0gPSB2YWx1ZVxuICAgIH1cbn0pXG5cblxuIiwiZXhwb3J0IGNvbnN0IE1FVEhPRF9UWVBFUyA9IFtcbiAgICAnZ2V0JyxcbiAgICAncG9zdCcsXG4gICAgJ2Zvcm0nLFxuICAgICdwdXNoJ1xuXVxuXG5leHBvcnQgY29uc3QgQ09OVEVOVF9UWVBFID0ge1xuICAgIEpTT046ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9VVRGLTgnLFxuICAgIEZPUk06ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLTgnXG59IiwiLyoqXG4gKiBEYXRhIHByb2Nlc3NpbmdcbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhRmlsdGVyaW5nKHBpcGVzLCBkYXRhLCBlcnJvckhvb2spIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXdEYXRhID0gW2RhdGEsIC4uLnBpcGVzXS5yZWR1Y2UoKHByZXYsIGN1cik9PmN1cihwcmV2KSlcbiAgICAgICAgcmV0dXJuIG5ld0RhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlcnJvckhvb2soZXJyb3IpXG4gICAgfVxufSJdfQ=="}