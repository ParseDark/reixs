{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js","node_modules/@babel/runtime/helpers/assertThisInitialized.js","node_modules/@babel/runtime/helpers/asyncToGenerator.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/setPrototypeOf.js","node_modules/@babel/runtime/helpers/typeof.js","node_modules/@babel/runtime/regenerator/index.js","node_modules/regenerator-runtime/runtime.js","src/core/create-request.js","src/core/handle-fetch.js","src/core/handler.js","src/core/request.js","src/core/separate-handler.js","src/reixs.js","src/shared/constants.js"],"names":[],"mappings":"AAAA;;;ACAA,MAAM,CAAC,OAAP,GAAiB,OAAO,CAAC,aAAD,CAAP,WAAjB;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACttBA;;;;;AAKA,SAAS,UAAT,CAAoB,IAApB,EAA0B;AACtB,SAAO,IAAI,KAAK,CAAT,GAAa,OAAO,CAAC,OAAR,EAAb,GACD,IAAI,OAAJ,CAAY,UAAA,OAAO,EAAE;AACnB,IAAA,UAAU,CAAC;AAAA,aAAI,OAAO,EAAX;AAAA,KAAD,EAAgB,IAAhB,CAAV;AACH,GAFC,CADN;AAIH;AAED;;;;;;;;AAMA,SAAS,YAAT,CAAsB,OAAtB,EAA+B,IAA/B,EAAqC;AACjC,MAAM,OAAO,GAAG,OAAO,CAAC,IAAR,CAAa,UAAA,IAAI;AAAA,WAAG;AAChC,MAAA,OAA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","file":"reixs.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports = require('./src/reixs').default","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","/**\n * Create delay promise\n * \n * @param {number} time \n */\nfunction createWait(time) {\n    return time === 0 ? Promise.resolve()\n        : new Promise(resolve=>{\n            setTimeout(()=>resolve(), time)\n        })\n}\n\n/**\n * Detect timeout\n * \n * @param {Promise} promise \n * @param {null|number} time \n */\nfunction requestTimer(promise, time) {\n    const request = promise.then(data=>({\n        timeout: false, \n        data\n    }))\n    const timer = createWait(time).then(()=>({\n        timeout: true, \n        data: null\n    }))\n    return time === null ? request\n        : Promise.race([request, timer])\n}\n\n/**\n * The method to create the request\n * \n * @param {Object} config \n * @param {Function} sendRequest \n * @param {Array} execute \n * @param {Object} hook \n */\nexport default function(config, sendRequest, execute, hook) {\n    let sym\n    let work = false\n    let wait = false\n    return async function(...par) {\n        const {throttle, discard, debounce, overtime} = config\n        const {startHook, endHook} = hook\n\n        /**\n         *  If throttle is set, the function must be idle to send the request.\n         *  If debounce is set. The request will not be triggered repeatedly \n         *  for a specified period of time.\n         */\n        if ((work && throttle) || wait) { \n            return \n        } \n\n        work = true\n        wait = true\n        await createWait(debounce)\n        wait = false\n        startHook && startHook(...par)\n        const mark = Symbol()\n        sym = mark\n\n        const {timeout, data} = await requestTimer(sendRequest(...par), overtime)\n\n        // If discard is set, the duplicate request is discarded\n        if (sym === mark || !discard) {\n            // If the timeout occurs, the task is not processed\n            if (!timeout) {\n                execute(data)\n            }\n\n            endHook && endHook(...par, timeout ? 'timeout' : 'successful')\n            work = false\n        }\n    }\n}\n\n","\n/**\n * Check for success\n * \n * @param {Object} response \n */\nfunction checkStatus(response) {\n    if (response.status >= 200 && response.status < 300) {\n        const contentType = response.headers.get('content-type')\n        if (contentType && contentType.includes('application/json')) {\n            return response.json()\n        } else {\n            return response.text()\n        }\n    } else {\n        throw new Error()\n    }\n}\n\n/**\n * Handle fetch\n * \n * @param {Object} promise \n */\nexport default function handleFetch(promise) {\n    return promise\n        .then(response => checkStatus(response))\n        .catch(error => {\n            throw error\n        })\n}","export default class {\n    _config = {\n        throttle: false,\n        discard: false,\n        debounce: 0,\n        overtime: null\n    }\n\n    _hook = {\n        tartHook: null,\n        endHook: null,\n        errorHook: null\n    }\n\n    _pipes = {\n        globalReqPipes: [],\n        globalResPipes: []\n    }\n    \n    _taskList =[]\n\n    /**\n     * Circular call task\n     * @param {*} data \n     */\n    _execute(data) {\n        const {errorHook} = this._hook\n        if (data !== undefined) {\n            try {\n                this._taskList.forEach(task =>{\n                    task(data)\n                })\n            } catch (error) {\n                errorHook && errorHook(error)\n            }\n        }\n    }\n\n    /**\n     * Set throttle\n     * \n     * @param {boolean} ifThrottle \n     */\n    setThrottle(ifThrottle) {\n        if (typeof time === 'boolean') {\n            this._config.throttle = ifThrottle\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Set discard\n     * \n     * @param {boolean} ifDiscard \n     */\n    setDiscard(ifDiscard) {\n        if (typeof time === 'boolean') {\n            this._config.discard = ifDiscard\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Set debounce\n     * \n     * @param {number} time \n     */\n    setDebounce(time) {\n        if (typeof time === 'number') {\n            this._config.debounce = time\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set overtime\n     * \n     * @param {nummber|null} time \n     */\n    setOvertime(time) {\n        if (typeof time === 'number' || time === null) {\n            this._config.overtime = time\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Add task\n     * \n     * @param {Function} task \n     */\n    task(task) {\n        if (typeof task === 'function') {\n            this._taskList.push(task)\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n\n    /**\n     * Request to start\n     * \n     * @param {Function} startHook \n     */\n    start(startHook) {\n        if (typeof startHook === 'function') {\n            this._hook.startHook = startHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Request to end\n     * \n     * @param {Function} endHook \n     */\n    end(endHook) {\n        if (typeof endHook === 'function') {\n            this._hook.endHook = endHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n    \n    /**\n     * Request to error\n     * \n     * @param {Function} errorHook \n     */\n    error(errorHook) {\n        if (typeof errorHook === 'function') {\n            this._hook.errorHook = errorHook\n            return this\n        } else {\n            throw new Error('Invalid type')\n        }\n    }\n}\n\n","import {CONTENT_TYPE} from '../shared/constants'\nimport handleFetch from './handle-fetch'\n\nexport default {\n    get(url, params, headers, cookie) {\n        url = new URL(url)\n        Object.keys(params)\n            .forEach(key => url.searchParams.append(key, params[key]))\n        const promise = fetch(url, {\n            method: 'GET',\n            headers: {\n                ...headers\n            },\n            credentials: cookie ? 'include' : 'omit'\n        })\n        return handleFetch(promise)\n    },\n\n    push(url, params, headers, cookie) {\n        url = new URL(url)\n        url.pathname += `/${params}`\n        const promise = fetch(url, {\n            method: 'GET',\n            headers: {\n                ...headers\n            },\n            credentials: cookie ? 'include' : 'omit'\n        })\n        return handleFetch(promise)\n    },\n\n    post(url, params, headers, cookie) {\n        url = new URL(url)\n        const promise = fetch(url, {\n            method: 'POST',\n            body: JSON.stringify(params),\n            headers: {\n                'Content-type': CONTENT_TYPE['JSON'],\n                ...headers\n            },\n            credentials: cookie ? 'include' : 'omit'\n        })\n        return handleFetch(promise)\n    },\n    \n    form(url, params, headers, cookie) {\n        url = new URL(url)\n        const promise = fetch(url, {\n            method: 'POST',\n            body: JSON.stringify(params),\n            headers: {\n                'Content-type': CONTENT_TYPE['FORM'],\n                ...headers\n            },\n            credentials: cookie ? 'include' : 'omit'\n        })\n        return handleFetch(promise)\n    }\n}","import {METHOD_TYPES} from '../shared/constants'\nimport request from './request'\nimport Handler from './handler'\nimport createRequest from './create-request'\n\nclass SeparateHandler  extends Handler {\n    constructor(url, method = 'get', params = null) {\n        super()\n        const {_config, _sendRequest, _execute, _hook} = this\n\n        // Initialize the http\n        this._http = {\n            ...this._http,\n            url,\n            params\n        }\n        this.setMethod(method)\n\n        // Create request function\n        this.request = createRequest(\n            _config, \n            _sendRequest.bind(this), \n            _execute.bind(this), \n            _hook\n        )\n    }\n\n    // Multiple requests Shared\n    static global = {\n        globalHeader: {},\n        globalParams: {} \n    }\n\n    _http = {\n        url: '',\n        method: null,\n        header: {},\n        params: null,\n        cookie: true\n    }\n    \n    get requesetHeader() {\n        const {header} = this._http\n        const {globalHeader} = this.constructor.global\n        return {\n            ...globalHeader, \n            ...header\n        }\n    }\n    \n    get requestParams() {\n        const {params} = this._http\n        const {globalParams} = this.constructor.global\n        return {\n            ...globalParams, \n            ...params\n        }\n    }\n\n    /**\n     * Set the request url\n     * \n     * @param {string} url \n     */\n    setUrl(url) {\n        if (typeof url === 'string') {\n            this._http.url = url\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n    \n    /**\n     * Set the request header\n     * \n     * @param {Object} header \n     */\n    setHeader(header) {\n        if (header.constructor === Object) {\n            this._http.header = header\n        } else {\n            throw new Error('Header invalid setting')\n        }\n        return this\n    }\n\n    /**\n     * Set request parameters\n     * \n     * @param {*} params \n     */\n    setParams(params) {\n        this._http.params = params\n        return this\n    }\n    \n    /**\n     * Set whether to carry cookies\n     * \n     * @param {boolean} ifCookie \n     */\n    setCookie(ifCookie) {\n        if (typeof ifCookie === 'boolean') {\n            this._http.cookie = ifCookie\n        } else {\n            throw new Error('Invalid type')\n        }\n        return this\n    }\n\n    /**\n     * Set the request method\n     * \n     * @param {string} method \n     */\n    setMethod(method = null) {\n        method = method.toLowerCase()\n        if (METHOD_TYPES.includes(method)) {\n            this._http.method = method\n        } else {\n            throw new Error('Invalid method')\n        }\n        return this\n    }\n    \n    /**\n     * Send the request to the server\n     * \n     * @param {*} params \n     * @param {string} type \n     */\n    async _sendRequest(params = this.params, type) {\n        const {url, method, cookie} = this._http\n\n        const requestType = type ? type : method\n        const requestParams = requestType === 'push' \n            ? params : this.requestParams\n        const data = await request[requestType](\n            url, \n            requestParams,\n            this.requesetHeader,\n            cookie\n        )\n        \n        return data\n    }\n}\n\n\n// Bind request category \nMETHOD_TYPES.map(requestType=>{\n    SeparateHandler.prototype[requestType] = function(params) {\n        this.request(params, requestType)\n    }\n})\n \n\nexport default SeparateHandler","import SeparateHandler from './core/separate-handler'\n\n/**\n * Create reixs \n * \n * @param {string} url \n * @param {string} method\n * @param {*} params  \n */\nfunction createInstance(url, method, params) {\n    return new Proxy(new SeparateHandler(url, method, params), {\n        set() {\n            throw new Error('Overwriting any attributes is not allowed')\n        }\n    })\n}\n\n/**\n * Set pipe \n * \n * @param {string} name \n * @param  {...any} funList \n */\nfunction setPipes(name, ...funList) {\n    SeparateHandler.globalPipes[name] = [...funList]\n}\n\nexport default new Proxy(createInstance, {\n    get(target, property) {\n        switch (property) {\n        // Replaced by browserify-versionify transform\n        case 'version':\n            return '__VERSION__'\n        // Set request and response pipe\n        case 'reqPipes':\n        case 'resPipes':\n            return setPipes.bind(null, property)\n        }\n    },\n    set(target, property, value) {\n        SeparateHandler.global[property] = value\n    }\n})\n\n\n","export const METHOD_TYPES = [\n    'get',\n    'post',\n    'form',\n    'push'\n]\n\nexport const CONTENT_TYPE = {\n    JSON: 'application/json;charset=UTF-8',\n    FORM: 'application/x-www-form-urlencoded; charset=UTF-8'\n}"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJzcmMvY29yZS9jcmVhdGUtcmVxdWVzdC5qcyIsInNyYy9jb3JlL2hhbmRsZS1mZXRjaC5qcyIsInNyYy9jb3JlL2hhbmRsZXIuanMiLCJzcmMvY29yZS9yZXF1ZXN0LmpzIiwic3JjL2NvcmUvc2VwYXJhdGUtaGFuZGxlci5qcyIsInNyYy9yZWl4cy5qcyIsInNyYy9zaGFyZWQvY29uc3RhbnRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNBQSxNQUFNLENBQUMsT0FBUCxHQUFpQixPQUFPLENBQUMsYUFBRCxDQUFQLFdBQWpCOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN0dEJBOzs7OztB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QU8sYUFBUDtBQUNKOztBQUNBLFdBQUssVUFBTDtBQUNBLFdBQUssVUFBTDtBQUNJLGVBQU8sUUFBUSxDQUFDLElBQVQsQ0FBYyxJQUFkLEVBQW9CLFFBQXBCLENBQVA7QUFQSjtBQVNILEdBWG9DO0FBWXJDLEVBQUEsR0FacUMsZUFZakMsTUFaaUMsRUFZekIsUUFaeUIsRUFZZixLQVplLEVBWVI7QUFDekIsZ0NBQWdCLE1BQWhCLENBQXVCLFFBQXZCLElBQW1DLEtBQW5DO0FBQ0g7QUFkb0MsQ0FBMUIsQzs7Ozs7Ozs7Ozs7QUMzQlIsSUFBTSxZQUFZLEdBQUcsQ0FDeEIsS0FEd0IsRUFFeEIsTUFGd0IsRUFHeEIsTUFId0IsRUFJeEIsTUFKd0IsQ0FBckI7O0FBT0EsSUFBTSxZQUFZLEdBQUc7QUFDeEIsRUFBQSxJQUFJLEVBQUUsZ0NBRGtCO0FBRXhCLEVBQUEsSUFBSSxFQUFFO0FBRmtCLENBQXJCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy9yZWl4cycpLmRlZmF1bHQiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZjIob2JqKTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YyKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIF90eXBlb2YyKG9iaik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IF90eXBlb2YyKG9iaik7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCIvKipcbiAqIENyZWF0ZSBkZWxheSBwcm9taXNlXG4gKiBcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFxuICovXG5mdW5jdGlvbiBjcmVhdGVXYWl0KHRpbWUpIHtcbiAgICByZXR1cm4gdGltZSA9PT0gMCA/IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIDogbmV3IFByb21pc2UocmVzb2x2ZT0+e1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+cmVzb2x2ZSgpLCB0aW1lKVxuICAgICAgICB9KVxufVxuXG4vKipcbiAqIERldGVjdCB0aW1lb3V0XG4gKiBcbiAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBcbiAqIEBwYXJhbSB7bnVsbHxudW1iZXJ9IHRpbWUgXG4gKi9cbmZ1bmN0aW9uIHJlcXVlc3RUaW1lcihwcm9taXNlLCB0aW1lKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHByb21pc2UudGhlbihkYXRhPT4oe1xuICAgICAgICB0aW1lb3V0OiBmYWxzZSwgXG4gICAgICAgIGRhdGFcbiAgICB9KSlcbiAgICBjb25zdCB0aW1lciA9IGNyZWF0ZVdhaXQodGltZSkudGhlbigoKT0+KHtcbiAgICAgICAgdGltZW91dDogdHJ1ZSwgXG4gICAgICAgIGRhdGE6IG51bGxcbiAgICB9KSlcbiAgICByZXR1cm4gdGltZSA9PT0gbnVsbCA/IHJlcXVlc3RcbiAgICAgICAgOiBQcm9taXNlLnJhY2UoW3JlcXVlc3QsIHRpbWVyXSlcbn1cblxuLyoqXG4gKiBUaGUgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgcmVxdWVzdFxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2VuZFJlcXVlc3QgXG4gKiBAcGFyYW0ge0FycmF5fSBleGVjdXRlIFxuICogQHBhcmFtIHtPYmplY3R9IGhvb2sgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbmZpZywgc2VuZFJlcXVlc3QsIGV4ZWN1dGUsIGhvb2spIHtcbiAgICBsZXQgc3ltXG4gICAgbGV0IHdvcmsgPSBmYWxzZVxuICAgIGxldCB3YWl0ID0gZmFsc2VcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4ucGFyKSB7XG4gICAgICAgIGNvbnN0IHt0aHJvdHRsZSwgZGlzY2FyZCwgZGVib3VuY2UsIG92ZXJ0aW1lfSA9IGNvbmZpZ1xuICAgICAgICBjb25zdCB7c3RhcnRIb29rLCBlbmRIb29rfSA9IGhvb2tcblxuICAgICAgICAvKipcbiAgICAgICAgICogIElmIHRocm90dGxlIGlzIHNldCwgdGhlIGZ1bmN0aW9uIG11c3QgYmUgaWRsZSB0byBzZW5kIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKiAgSWYgZGVib3VuY2UgaXMgc2V0LiBUaGUgcmVxdWVzdCB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgcmVwZWF0ZWRseSBcbiAgICAgICAgICogIGZvciBhIHNwZWNpZmllZCBwZXJpb2Qgb2YgdGltZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICgod29yayAmJiB0aHJvdHRsZSkgfHwgd2FpdCkgeyBcbiAgICAgICAgICAgIHJldHVybiBcbiAgICAgICAgfSBcblxuICAgICAgICB3b3JrID0gdHJ1ZVxuICAgICAgICB3YWl0ID0gdHJ1ZVxuICAgICAgICBhd2FpdCBjcmVhdGVXYWl0KGRlYm91bmNlKVxuICAgICAgICB3YWl0ID0gZmFsc2VcbiAgICAgICAgc3RhcnRIb29rICYmIHN0YXJ0SG9vayguLi5wYXIpXG4gICAgICAgIGNvbnN0IG1hcmsgPSBTeW1ib2woKVxuICAgICAgICBzeW0gPSBtYXJrXG5cbiAgICAgICAgY29uc3Qge3RpbWVvdXQsIGRhdGF9ID0gYXdhaXQgcmVxdWVzdFRpbWVyKHNlbmRSZXF1ZXN0KC4uLnBhciksIG92ZXJ0aW1lKVxuXG4gICAgICAgIC8vIElmIGRpc2NhcmQgaXMgc2V0LCB0aGUgZHVwbGljYXRlIHJlcXVlc3QgaXMgZGlzY2FyZGVkXG4gICAgICAgIGlmIChzeW0gPT09IG1hcmsgfHwgIWRpc2NhcmQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0aW1lb3V0IG9jY3VycywgdGhlIHRhc2sgaXMgbm90IHByb2Nlc3NlZFxuICAgICAgICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZShkYXRhKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbmRIb29rICYmIGVuZEhvb2soLi4ucGFyLCB0aW1lb3V0ID8gJ3RpbWVvdXQnIDogJ3N1Y2Nlc3NmdWwnKVxuICAgICAgICAgICAgd29yayA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIlxuLyoqXG4gKiBDaGVjayBmb3Igc3VjY2Vzc1xuICogXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU3RhdHVzKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpXG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICAgIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgZmV0Y2hcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IHByb21pc2UgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhhbmRsZUZldGNoKHByb21pc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiBjaGVja1N0YXR1cyhyZXNwb25zZSkpXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9KVxufSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgICBfY29uZmlnID0ge1xuICAgICAgICB0aHJvdHRsZTogZmFsc2UsXG4gICAgICAgIGRpc2NhcmQ6IGZhbHNlLFxuICAgICAgICBkZWJvdW5jZTogMCxcbiAgICAgICAgb3ZlcnRpbWU6IG51bGxcbiAgICB9XG5cbiAgICBfaG9vayA9IHtcbiAgICAgICAgdGFydEhvb2s6IG51bGwsXG4gICAgICAgIGVuZEhvb2s6IG51bGwsXG4gICAgICAgIGVycm9ySG9vazogbnVsbFxuICAgIH1cblxuICAgIF9waXBlcyA9IHtcbiAgICAgICAgZ2xvYmFsUmVxUGlwZXM6IFtdLFxuICAgICAgICBnbG9iYWxSZXNQaXBlczogW11cbiAgICB9XG4gICAgXG4gICAgX3Rhc2tMaXN0ID1bXVxuXG4gICAgLyoqXG4gICAgICogQ2lyY3VsYXIgY2FsbCB0YXNrXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFxuICAgICAqL1xuICAgIF9leGVjdXRlKGRhdGEpIHtcbiAgICAgICAgY29uc3Qge2Vycm9ySG9va30gPSB0aGlzLl9ob29rXG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFza0xpc3QuZm9yRWFjaCh0YXNrID0+e1xuICAgICAgICAgICAgICAgICAgICB0YXNrKGRhdGEpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JIb29rICYmIGVycm9ySG9vayhlcnJvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aHJvdHRsZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWZUaHJvdHRsZSBcbiAgICAgKi9cbiAgICBzZXRUaHJvdHRsZShpZlRocm90dGxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGltZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcudGhyb3R0bGUgPSBpZlRocm90dGxlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGlzY2FyZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWZEaXNjYXJkIFxuICAgICAqL1xuICAgIHNldERpc2NhcmQoaWZEaXNjYXJkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGltZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcuZGlzY2FyZCA9IGlmRGlzY2FyZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlYm91bmNlXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgXG4gICAgICovXG4gICAgc2V0RGVib3VuY2UodGltZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcuZGVib3VuY2UgPSB0aW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IG92ZXJ0aW1lXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1tYmVyfG51bGx9IHRpbWUgXG4gICAgICovXG4gICAgc2V0T3ZlcnRpbWUodGltZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRpbWUgPT09ICdudW1iZXInIHx8IHRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5vdmVydGltZSA9IHRpbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBBZGQgdGFza1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2sgXG4gICAgICovXG4gICAgdGFzayh0YXNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fdGFza0xpc3QucHVzaCh0YXNrKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdG8gc3RhcnRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdGFydEhvb2sgXG4gICAgICovXG4gICAgc3RhcnQoc3RhcnRIb29rKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhcnRIb29rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9ob29rLnN0YXJ0SG9vayA9IHN0YXJ0SG9va1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHRvIGVuZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVuZEhvb2sgXG4gICAgICovXG4gICAgZW5kKGVuZEhvb2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmRIb29rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9ob29rLmVuZEhvb2sgPSBlbmRIb29rXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdG8gZXJyb3JcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvckhvb2sgXG4gICAgICovXG4gICAgZXJyb3IoZXJyb3JIb29rKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JIb29rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9ob29rLmVycm9ySG9vayA9IGVycm9ySG9va1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJylcbiAgICAgICAgfVxuICAgIH1cbn1cblxuIiwiaW1wb3J0IHtDT05URU5UX1RZUEV9IGZyb20gJy4uL3NoYXJlZC9jb25zdGFudHMnXG5pbXBvcnQgaGFuZGxlRmV0Y2ggZnJvbSAnLi9oYW5kbGUtZmV0Y2gnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBnZXQodXJsLCBwYXJhbXMsIGhlYWRlcnMsIGNvb2tpZSkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKHVybClcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKVxuICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgcGFyYW1zW2tleV0pKVxuICAgICAgICBjb25zdCBwcm9taXNlID0gZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVkZW50aWFsczogY29va2llID8gJ2luY2x1ZGUnIDogJ29taXQnXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBoYW5kbGVGZXRjaChwcm9taXNlKVxuICAgIH0sXG5cbiAgICBwdXNoKHVybCwgcGFyYW1zLCBoZWFkZXJzLCBjb29raWUpIHtcbiAgICAgICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgICAgIHVybC5wYXRobmFtZSArPSBgLyR7cGFyYW1zfWBcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IGZldGNoKHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IGNvb2tpZSA/ICdpbmNsdWRlJyA6ICdvbWl0J1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gaGFuZGxlRmV0Y2gocHJvbWlzZSlcbiAgICB9LFxuXG4gICAgcG9zdCh1cmwsIHBhcmFtcywgaGVhZGVycywgY29va2llKSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwodXJsKVxuICAgICAgICBjb25zdCBwcm9taXNlID0gZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcmFtcyksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtdHlwZSc6IENPTlRFTlRfVFlQRVsnSlNPTiddLFxuICAgICAgICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVkZW50aWFsczogY29va2llID8gJ2luY2x1ZGUnIDogJ29taXQnXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBoYW5kbGVGZXRjaChwcm9taXNlKVxuICAgIH0sXG4gICAgXG4gICAgZm9ybSh1cmwsIHBhcmFtcywgaGVhZGVycywgY29va2llKSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwodXJsKVxuICAgICAgICBjb25zdCBwcm9taXNlID0gZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcmFtcyksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtdHlwZSc6IENPTlRFTlRfVFlQRVsnRk9STSddLFxuICAgICAgICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVkZW50aWFsczogY29va2llID8gJ2luY2x1ZGUnIDogJ29taXQnXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBoYW5kbGVGZXRjaChwcm9taXNlKVxuICAgIH1cbn0iLCJpbXBvcnQge01FVEhPRF9UWVBFU30gZnJvbSAnLi4vc2hhcmVkL2NvbnN0YW50cydcbmltcG9ydCByZXF1ZXN0IGZyb20gJy4vcmVxdWVzdCdcbmltcG9ydCBIYW5kbGVyIGZyb20gJy4vaGFuZGxlcidcbmltcG9ydCBjcmVhdGVSZXF1ZXN0IGZyb20gJy4vY3JlYXRlLXJlcXVlc3QnXG5cbmNsYXNzIFNlcGFyYXRlSGFuZGxlciAgZXh0ZW5kcyBIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG1ldGhvZCA9ICdnZXQnLCBwYXJhbXMgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgY29uc3Qge19jb25maWcsIF9zZW5kUmVxdWVzdCwgX2V4ZWN1dGUsIF9ob29rfSA9IHRoaXNcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBodHRwXG4gICAgICAgIHRoaXMuX2h0dHAgPSB7XG4gICAgICAgICAgICAuLi50aGlzLl9odHRwLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRNZXRob2QobWV0aG9kKVxuXG4gICAgICAgIC8vIENyZWF0ZSByZXF1ZXN0IGZ1bmN0aW9uXG4gICAgICAgIHRoaXMucmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoXG4gICAgICAgICAgICBfY29uZmlnLCBcbiAgICAgICAgICAgIF9zZW5kUmVxdWVzdC5iaW5kKHRoaXMpLCBcbiAgICAgICAgICAgIF9leGVjdXRlLmJpbmQodGhpcyksIFxuICAgICAgICAgICAgX2hvb2tcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8vIE11bHRpcGxlIHJlcXVlc3RzIFNoYXJlZFxuICAgIHN0YXRpYyBnbG9iYWwgPSB7XG4gICAgICAgIGdsb2JhbEhlYWRlcjoge30sXG4gICAgICAgIGdsb2JhbFBhcmFtczoge30gXG4gICAgfVxuXG4gICAgX2h0dHAgPSB7XG4gICAgICAgIHVybDogJycsXG4gICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgaGVhZGVyOiB7fSxcbiAgICAgICAgcGFyYW1zOiBudWxsLFxuICAgICAgICBjb29raWU6IHRydWVcbiAgICB9XG4gICAgXG4gICAgZ2V0IHJlcXVlc2V0SGVhZGVyKCkge1xuICAgICAgICBjb25zdCB7aGVhZGVyfSA9IHRoaXMuX2h0dHBcbiAgICAgICAgY29uc3Qge2dsb2JhbEhlYWRlcn0gPSB0aGlzLmNvbnN0cnVjdG9yLmdsb2JhbFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZ2xvYmFsSGVhZGVyLCBcbiAgICAgICAgICAgIC4uLmhlYWRlclxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGdldCByZXF1ZXN0UGFyYW1zKCkge1xuICAgICAgICBjb25zdCB7cGFyYW1zfSA9IHRoaXMuX2h0dHBcbiAgICAgICAgY29uc3Qge2dsb2JhbFBhcmFtc30gPSB0aGlzLmNvbnN0cnVjdG9yLmdsb2JhbFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZ2xvYmFsUGFyYW1zLCBcbiAgICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IHVybFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgXG4gICAgICovXG4gICAgc2V0VXJsKHVybCkge1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAudXJsID0gdXJsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IGhlYWRlclxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXIgXG4gICAgICovXG4gICAgc2V0SGVhZGVyKGhlYWRlcikge1xuICAgICAgICBpZiAoaGVhZGVyLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAuaGVhZGVyID0gaGVhZGVyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYWRlciBpbnZhbGlkIHNldHRpbmcnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHJlcXVlc3QgcGFyYW1ldGVyc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gcGFyYW1zIFxuICAgICAqL1xuICAgIHNldFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5faHR0cC5wYXJhbXMgPSBwYXJhbXNcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdG8gY2FycnkgY29va2llc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWZDb29raWUgXG4gICAgICovXG4gICAgc2V0Q29va2llKGlmQ29va2llKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWZDb29raWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5faHR0cC5jb29raWUgPSBpZkNvb2tpZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZXF1ZXN0IG1ldGhvZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgXG4gICAgICovXG4gICAgc2V0TWV0aG9kKG1ldGhvZCA9IG51bGwpIHtcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKClcbiAgICAgICAgaWYgKE1FVEhPRF9UWVBFUy5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzLl9odHRwLm1ldGhvZCA9IG1ldGhvZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCcpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgcmVxdWVzdCB0byB0aGUgc2VydmVyXG4gICAgICogXG4gICAgICogQHBhcmFtIHsqfSBwYXJhbXMgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXG4gICAgICovXG4gICAgYXN5bmMgX3NlbmRSZXF1ZXN0KHBhcmFtcyA9IHRoaXMucGFyYW1zLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHt1cmwsIG1ldGhvZCwgY29va2llfSA9IHRoaXMuX2h0dHBcblxuICAgICAgICBjb25zdCByZXF1ZXN0VHlwZSA9IHR5cGUgPyB0eXBlIDogbWV0aG9kXG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSByZXF1ZXN0VHlwZSA9PT0gJ3B1c2gnIFxuICAgICAgICAgICAgPyBwYXJhbXMgOiB0aGlzLnJlcXVlc3RQYXJhbXNcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcXVlc3RbcmVxdWVzdFR5cGVdKFxuICAgICAgICAgICAgdXJsLCBcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMsXG4gICAgICAgICAgICB0aGlzLnJlcXVlc2V0SGVhZGVyLFxuICAgICAgICAgICAgY29va2llXG4gICAgICAgIClcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxufVxuXG5cbi8vIEJpbmQgcmVxdWVzdCBjYXRlZ29yeSBcbk1FVEhPRF9UWVBFUy5tYXAocmVxdWVzdFR5cGU9PntcbiAgICBTZXBhcmF0ZUhhbmRsZXIucHJvdG90eXBlW3JlcXVlc3RUeXBlXSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB0aGlzLnJlcXVlc3QocGFyYW1zLCByZXF1ZXN0VHlwZSlcbiAgICB9XG59KVxuIFxuXG5leHBvcnQgZGVmYXVsdCBTZXBhcmF0ZUhhbmRsZXIiLCJpbXBvcnQgU2VwYXJhdGVIYW5kbGVyIGZyb20gJy4vY29yZS9zZXBhcmF0ZS1oYW5kbGVyJ1xuXG4vKipcbiAqIENyZWF0ZSByZWl4cyBcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7Kn0gcGFyYW1zICBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UodXJsLCBtZXRob2QsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJveHkobmV3IFNlcGFyYXRlSGFuZGxlcih1cmwsIG1ldGhvZCwgcGFyYW1zKSwge1xuICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJ3cml0aW5nIGFueSBhdHRyaWJ1dGVzIGlzIG5vdCBhbGxvd2VkJylcbiAgICAgICAgfVxuICAgIH0pXG59XG5cbi8qKlxuICogU2V0IHBpcGUgXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICogQHBhcmFtICB7Li4uYW55fSBmdW5MaXN0IFxuICovXG5mdW5jdGlvbiBzZXRQaXBlcyhuYW1lLCAuLi5mdW5MaXN0KSB7XG4gICAgU2VwYXJhdGVIYW5kbGVyLmdsb2JhbFBpcGVzW25hbWVdID0gWy4uLmZ1bkxpc3RdXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBQcm94eShjcmVhdGVJbnN0YW5jZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgLy8gUmVwbGFjZWQgYnkgYnJvd3NlcmlmeS12ZXJzaW9uaWZ5IHRyYW5zZm9ybVxuICAgICAgICBjYXNlICd2ZXJzaW9uJzpcbiAgICAgICAgICAgIHJldHVybiAnX19WRVJTSU9OX18nXG4gICAgICAgIC8vIFNldCByZXF1ZXN0IGFuZCByZXNwb25zZSBwaXBlXG4gICAgICAgIGNhc2UgJ3JlcVBpcGVzJzpcbiAgICAgICAgY2FzZSAncmVzUGlwZXMnOlxuICAgICAgICAgICAgcmV0dXJuIHNldFBpcGVzLmJpbmQobnVsbCwgcHJvcGVydHkpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBTZXBhcmF0ZUhhbmRsZXIuZ2xvYmFsW3Byb3BlcnR5XSA9IHZhbHVlXG4gICAgfVxufSlcblxuXG4iLCJleHBvcnQgY29uc3QgTUVUSE9EX1RZUEVTID0gW1xuICAgICdnZXQnLFxuICAgICdwb3N0JyxcbiAgICAnZm9ybScsXG4gICAgJ3B1c2gnXG5dXG5cbmV4cG9ydCBjb25zdCBDT05URU5UX1RZUEUgPSB7XG4gICAgSlNPTjogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCcsXG4gICAgRk9STTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOCdcbn0iXX0="}